package rs.ac.bg.etf.pp1;
import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import org.apache.log4j.xml.DOMConfigurator;
import rs.ac.bg.etf.pp1.util.Log4JUtils;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.util.DumpSymbolTableVisitorModified;

parser code {:
	
	static {
		DOMConfigurator.configure(Log4JUtils.instance().findLoggerConfigFile());
		Log4JUtils.instance().prepareLogFile(Logger.getRootLogger());
	}

	public boolean errorFound = false;
	public boolean isGlobal = true;				// globalne prom
	public boolean mainMethod = false;			// da li je main metoda glavne klase
	public boolean inner = false;				// unutrasnje klase
	public boolean local = false;				// koristim za polja unutrasnjih klasa
	
	// BROJACI ZA NIVO A
   	public int var_count = 0;
	public int main_var_count = 0;
	public int const_count = 0;
   	public int array_count = 0;
   	
   	// BROJACI ZA NIVO B	
   	public int function_cnt = 0;
   	public int statement_cnt = 0;
   	public int main_method_calls = 0;
   	public int formal_param_cnt = 0;
   	
   	// BROJACI ZA NIVO C
	public int inner_class_cnt = 0;
	public int inner_class_meth_cnt = 0;
	public int inner_class_field_cnt = 0;
   	
	public static void main(String[] args) throws Exception {
		Logger log = Logger.getLogger(MJParser.class);	
		Reader br = null;
		
		try {
			if (args.length < 1) {
				log.error("Not enough arguments supplied! Usage: MJParser <source-file>");
				return;
			}
			
			File sourceCode = new File(args[0]);
			if (!sourceCode.exists()) {
				log.error("Source file [" + sourceCode.getAbsolutePath() + "] not found!");
				return;
			}
				
			log.info("Compiling source file: " + sourceCode.getAbsolutePath());
			
			br = new BufferedReader(new FileReader(sourceCode));
			Yylex lexer = new Yylex(br);
			
			MJParser p = new MJParser(lexer);
	        Symbol s = p.parse();  //pocetak parsiranja
	        
	        /*
	         * ISPIS SADRZAJA TABELE SIMBOLA
	         */
	        DumpSymbolTableVisitorModified ds = new DumpSymbolTableVisitorModified();
	        Tab.dump(ds);
	        
	        if (p.errorFound) {
	        	log.error("Parsiranje nije uspesno zavrseno!");
	        }
	        else {
	        	System.out.println("=====================SINTAKSNA ANALIZA=========================");
	        	System.out.println(p.var_count + "\tglobalne promenljive" );
			   	System.out.println(p.main_var_count + "\tlokalne promenljive (u main funkciji)");
			   	System.out.println(p.const_count + "\tglobalne konstante");
			   	System.out.println(p.array_count + "\tglobalni nizovi");
			   	
				System.out.println(p.function_cnt + "\tfunkcije u glavnom programu");
				System.out.println(p.statement_cnt + "\tblokovi naredbi");
				System.out.println(p.main_method_calls + "\tpozivi funkcija u telu metode main");
				System.out.println(p.formal_param_cnt + "\tformalni argumenti funkcija");
			   	
				System.out.println(p.inner_class_cnt + "\tunutrasnje klase");
				System.out.println(p.inner_class_meth_cnt + "\tmetode unutrasnjih klasa");
				System.out.println(p.inner_class_field_cnt + "\tpolja unutrasnjih klasa");
	        	System.out.println("\nParsiranje je uspesno zavrseno!");
	        }
	        
		} 
		finally {
			if (br != null) try { br.close(); } catch (IOException e1) { log.error(e1.getMessage(), e1); }
		}
	}
	
	Logger log = Logger.getLogger(getClass());
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
	
	// ovde se moze izvrsiti oporavak
	public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
	
	// ovde se ne moze izvrsiti oporavak
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }
	
	public void report_error(String message, Object info){
		errorFound = true;
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
	      	msg.append(" na liniji ").append(((Symbol)info).left);
	    log.error(message);
    }
	
	public void report_info(String message, Object info){
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
	      	msg.append(" na liniji ").append(((Symbol)info).left);
		System.out.println(message);
    }
	
	public String writeObj(Obj obj)
	{
		String message = "";
		if (obj != null)
		{
			DumpSymbolTableVisitorModified ds = new DumpSymbolTableVisitorModified();
			obj.accept(ds);
			message = ds.getOutput();
		}
		return message;
	}
	
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		System.out.println(s.toString() + " " + s.value.toString());
	return s;
:}

init with {: 
	
	Tab.init();					// Universe scope	

	Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool", CUP$MJParser$actions.boolType));
	Tab.currentScope.addToLocals(new Obj(Obj.Type, "string", CUP$MJParser$actions.stringType));
	
	errorFound = false;
	mainMethod = false;
	isGlobal = true;
	inner = false;
	local = false;

	var_count = 0;
	main_var_count = 0;
	const_count = 0;
   	array_count = 0;
   	function_cnt = 0;
   	statement_cnt = 0;
   	main_method_calls = 0;
   	formal_param_cnt = 0;
   	inner_class_cnt = 0;
   	inner_class_meth_cnt = 0;
   	inner_class_field_cnt = 0;
:}

action code {:  
	Logger log = Logger.getLogger(getClass());

	public static final Struct boolType = new Struct(Struct.Bool);
	//public static final Struct stringType = new Struct(Struct.Array, Tab.charType);
	public static final Struct stringType = new Struct(6);
	
	Obj currentMethod = null, currentClass = null, currentDesignator = null;
	Struct currentType = Tab.noType;
	int lastClass = 0;
	
:}

terminal PROGRAM, IDENT, LBRACE, RBRACE;
terminal CONST, SEMI_COMMA, EQUALS, NUMBER, CHARCONST, BOOLCONST, STRCONST, COMMA;
terminal LBRACKET, RBRACKET;
terminal CLASS, EXTENDS;
terminal VOID, LPAREN, RPAREN;
terminal INC, DEC, IF, WHILE, BREAK, RETURN, READ, ELSE, PRINT;
terminal OR;
terminal AND;
terminal MINUS;
terminal NEW;
terminal DOT;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL;
terminal PLUS;
terminal TIMES, DIV, MOD;

non terminal Program, DeclarationList, MethodDeclarationList, DeclarationPart, ConstDecl, VarDecl, ClassDecl, MethodDecl;
non terminal ConstDeclIdent, ConstDeclIdentList;
non terminal VarDeclList, VarDeclPart;
non terminal LocalVarDeclList, ClassDeclMethodDeclaration, LocalMethodDeclList;
non terminal MethodDeclPart, FormPars, MethodPars, StatementList, Statement;
non terminal FormPar;
non terminal Assignment, Expr, ExprPart, Condition, ConditionFixed, ActPars, StatementUnmatched, StatementMatched;
non terminal CondTerm, CondTermFixed;
non terminal CondFact;
non terminal Relop;
non terminal Term, Addop;
non terminal FactorList, Mulop, Factor;
non terminal DesignatorList, DesignatorPart;

/*
 *  ZA SEMANTICKU ANALIZU 
 */
non terminal Obj ProgramName, MethodName, Designator, Val, ClassName;
non terminal Struct Type;
non terminal OpenScope, CloseScope;
non terminal String ClassBase;
/*
 *  **********************
 */

start with Program;

OpenScope ::= {: Tab.openScope(); :};

CloseScope ::= {: Tab.closeScope(); :};

/***********************************************************************
     Program
***********************************************************************/
    
Program ::= PROGRAM ProgramName:p OpenScope DeclarationList LBRACE 
			{:
				parser.isGlobal = false;
			:}
			MethodDeclarationList RBRACE
			{:
				Tab.chainLocalSymbols(p);
			:}
			CloseScope;

ProgramName ::= IDENT:pName
				{:
					RESULT = Tab.insert(Obj.Prog, pName.toString(), Tab.noType);
				:};

DeclarationList ::= DeclarationList DeclarationPart
					|
					/* epsilon */;
			
DeclarationPart ::= ConstDecl
					|
					VarDecl
					|
					ClassDecl;

MethodDeclarationList ::= MethodDeclarationList MethodDecl
						  |
						  /* epsilon */;
						  
/***********************************************************************
     ConstDecl
***********************************************************************/
    				  
ConstDecl ::= CONST Type ConstDeclIdentList SEMI_COMMA;

ConstDeclIdentList ::= ConstDeclIdentList COMMA ConstDeclIdent
					   |
					   ConstDeclIdent;

ConstDeclIdent ::= IDENT:constName EQUALS Val:constValue 
				   {: 
					   if (parser.isGlobal) parser.const_count++;
				   	   if (Tab.currentScope.findSymbol(constName.toString()) != null)
				   		   parser.report_error("[Greska]Linija: " + constNameleft + "\t" + constName + " je vec deklarisano", null);
				   	   else
				   	   {
				   		   Obj cons = Tab.insert(Obj.Con, constName.toString(), currentType);
				   		   cons.setAdr(((Obj) constValue).getAdr());						// adr = value
				   		   if(((Obj) constValue).getType() != currentType)
				   			   parser.report_error("[Greska]Linija: " + constValueleft + "\tTip " + constValue + " je neispravan", null);
				   	   }	   
				   :}
				   |
				   IDENT:constName EQUALS BOOLCONST:constValue 
				   {: 
					   if (parser.isGlobal) parser.const_count++;
					   if (Tab.currentScope.findSymbol(constName.toString()) != null)
				   		   parser.report_error("[Greska]Linija: " + constNameleft + "\t" + constName + " je vec deklarisano", null);
				   	   else
				   	   {
				   		   Obj cons = Tab.insert(Obj.Con, constName.toString(), boolType);
				   		   cons.setAdr((boolean)constValue? 1:0);						// adr = value
				   	   }
				   :}
				   |
				   IDENT:constName EQUALS STRCONST:constValue 
				   {: 
					   if (parser.isGlobal) parser.const_count++;
					   if (Tab.currentScope.findSymbol(constName.toString()) != null)
				   		   parser.report_error("[Greska]Linija: " + constNameleft + "\t" + constName + " je vec deklarisano", null);
				   	   else
				   	   {
				   		   Obj consVar = Tab.insert(Obj.Var, "@@@" + constName.toString(), new Struct(Struct.Array, Tab.charType));
				   		   Obj cons = Tab.insert(Obj.Con, constName.toString(), stringType);
				   		   cons.setAdr(consVar.getAdr());
				   		   
				   	   }
				   :};

Val ::= NUMBER:val
		{:
			RESULT = new Obj(Obj.Con, "", Tab.intType);  
			((Obj) RESULT).setAdr((int)val); 
		:}
		|
		CHARCONST:val
		{:
			RESULT = new Obj(Obj.Con, "", Tab.charType);  
			((Obj) RESULT).setAdr((char)val);
		:};

/***********************************************************************
     VarDecl
***********************************************************************/

VarDecl ::= Type:currentType VarDeclList SEMI_COMMA;

VarDeclList ::= VarDeclList COMMA VarDeclPart
				|
				VarDeclPart;
				
VarDeclPart ::= IDENT:varName 
				{:
					// Brojanje lokalnih promenljivih main funkcije i globalnih promenljivih
					if (parser.mainMethod) parser.main_var_count++;
					else if (parser.isGlobal) parser.var_count++;
					else if (parser.inner && !parser.local) parser.inner_class_field_cnt++;

					Tab.insert(parser.inner && !parser.local? Obj.Fld: Obj.Var, varName.toString(), currentType);
				:}
				|
				IDENT:varName LBRACKET RBRACKET
				{:
					// Brojanje lokalnih promenljivih main funkcije i globalnih nizova
					if (parser.mainMethod) parser.main_var_count++;
					else if (parser.isGlobal) parser.array_count++;
					else if (parser.inner && !parser.local) parser.inner_class_field_cnt++;
					
					Tab.insert(parser.inner && !parser.local? Obj.Fld: Obj.Var, varName.toString(), new Struct(Struct.Array, currentType));
				:};


/***********************************************************************
     ClassDecl
***********************************************************************/

ClassDecl ::= CLASS ClassName:className OpenScope LBRACE 
			  {: 
				  parser.inner = true;
				  parser.isGlobal = false; 
				  parser.local = false;
			  :} 
			  LocalVarDeclList 
			  {:
				  parser.local = true;
			  :}
			  ClassDeclMethodDeclaration RBRACE 
			  {:
				  parser.inner = false;
				  parser.isGlobal = true;
				  
				  Tab.chainLocalSymbols(currentClass.getType());
			  :}
			  CloseScope
			  |
			  CLASS ClassName:className EXTENDS ClassBase:baseClassName OpenScope 
			  {:
				  Obj base = Tab.find(baseClassName.toString());
				  
				  // "kopira" polja i metode superklase u svoju klasu
				  for (Obj o: base.getType().getMembers())
				  {
					  Obj attr = Tab.insert(o.getKind(), o.getName(), o.getType());
					  attr.setAdr(o.getAdr());
				  }
			  :}
			  LBRACE 
			  {: 
				  parser.inner = true;
				  parser.isGlobal = false; 
				  parser.local = false;
			  :} 
			  LocalVarDeclList 
			  {:
				  parser.local = true;
			  :}
			  ClassDeclMethodDeclaration RBRACE 
			  {:
				  parser.inner = false;
				  parser.isGlobal = true;
				  
				  Tab.chainLocalSymbols(currentClass.getType());
			  :}
			  CloseScope;

ClassName ::= IDENT:className
			  {:
				  parser.inner_class_cnt++;

				  currentClass = Tab.insert(Obj.Type, className.toString(), new Struct(Struct.Class));
				  
			  :};

ClassBase ::= IDENT:baseName
			  {:
				  RESULT = baseName.toString();
			  :};
			  
LocalVarDeclList ::= LocalVarDeclList VarDecl
					 |
					 /* epsilon */;
						 
ClassDeclMethodDeclaration ::= LBRACE LocalMethodDeclList RBRACE
				  			   |
				  			   /* epsilon */;
				  			   
LocalMethodDeclList ::= LocalMethodDeclList MethodDecl
						|
						/* epsilon */;		  

/***********************************************************************
     MethodDecl
***********************************************************************/				  

MethodDecl ::= Type MethodDeclPart
			   |
			   VOID {: currentType = Tab.noType; :} MethodDeclPart;
				  
MethodDeclPart ::= MethodName OpenScope 
				   {:
					   if (parser.inner)
					   {
						   parser.inner_class_meth_cnt++;
						   // Ne znam kako bih drugacije postavila ClassType
						   Tab.insert(Obj.Var, "this", currentClass.getType());
						   currentMethod.setLevel(1);	// jer ima this implicitni
					   }
					   else
						   parser.function_cnt++;
				   :} 
				   LPAREN MethodPars:numForPars RPAREN LocalVarDeclList LBRACE StatementList RBRACE
				   {:
					   // level = broj formalnih parametara
					   	currentMethod.setLevel(currentMethod.getLevel() + (int)numForPars);
				   		Tab.chainLocalSymbols(currentMethod);
				   		parser.mainMethod = false;
				   :}
				   CloseScope; 				  

MethodName ::= IDENT:methName
			   {:
				   if (methName.equals("main")) parser.mainMethod = true;
				   currentMethod = Tab.insert(Obj.Meth, methName.toString(), currentType);
			   :};				   
				   
MethodPars ::= FormPars:numForPars
			   {:
				  RESULT = numForPars; 
			   :}
			   |
			   /* epsilon */
			   {: 
				   RESULT = 0; 
			   :};					
					
StatementList ::= StatementList Statement
				  |
				  /* epsilon */;				
								  
/***********************************************************************
     FormPars
***********************************************************************/
 
FormPars ::= FormPars:numForPars COMMA FormPar
			 {: 
				 RESULT = (int)numForPars + 1; 
			 :}
		 	 |
			 FormPar
			 {: 
				 RESULT = 1; 
			 :};
				  
FormPar ::= Type IDENT:formVarName 
			{: 
				parser.formal_param_cnt++;
				Tab.insert(Obj.Var, formVarName.toString(), currentType);
			:}
			|
			Type IDENT:formVarName LBRACKET RBRACKET 
			{: 
				parser.formal_param_cnt++;
				Tab.insert(Obj.Var, formVarName.toString(), new Struct(Struct.Array, currentType));
			:};				  
				  
/***********************************************************************
     Type
***********************************************************************/				  
				  
Type ::= IDENT:typeName
		 {:
			 Obj typeNode = Tab.find(typeName.toString());
			 if (typeNode == Tab.noObj)
			 {
				 //ime ne postoji u tabeli simbola, treba prijaviti semanticku gresku
				 parser.report_error("[Greska]Linija: " + typeNameleft + "\tNije pronadjen tip " + typeName + " u tabeli simbola!", null);
				 currentType = Tab.noType;
			 }
			 else
			 {
				 if (Obj.Type == typeNode.getKind())
				 {
					 currentType = typeNode.getType();
					 RESULT = currentType;
					 
				 }
				 else
				 {
					 // ne predstavlja tip, nego nesto drugo; greska
					 parser.report_error("[Greska]Linija: " + typeNameleft + "\tIme " + typeName + " ne predstavlja tip ", null);
					 currentType = Tab.noType;
				 }
			 }
			 
		 :};

/***********************************************************************
     Statement
***********************************************************************/			  

Statement ::= StatementUnmatched
			  |
			  StatementMatched;

StatementUnmatched ::= IF LPAREN ConditionFixed RPAREN Statement
					   |
					   IF LPAREN ConditionFixed RPAREN StatementMatched ELSE StatementUnmatched
					   |
					   WHILE LPAREN ConditionFixed RPAREN StatementUnmatched;
					   
StatementMatched ::= Assignment
					  |
					  Designator:func LPAREN ActPars RPAREN SEMI_COMMA  
					  {: 
						  if (parser.mainMethod) parser.main_method_calls++;
//						  if (Obj.Meth == func.getKind())
//							   parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
//						  else
//							   parser.report_error("Greska na liniji " + funcleft + ": ime " + func.getName() + " nije funkcija!", null);
					  :}
					  |
					  Designator:func LPAREN RPAREN SEMI_COMMA  
					  {: 
						  if (parser.mainMethod) parser.main_method_calls++;
//						  if (Obj.Meth == func.getKind())
//							   parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
//						  else
//							   parser.report_error("Greska na liniji " + funcleft + ": ime " + func.getName() + " nije funkcija!", null);
					  :}
					  |
					  Designator INC SEMI_COMMA
					  |
					  Designator DEC SEMI_COMMA
					  |
					  IF LPAREN ConditionFixed RPAREN StatementMatched ELSE StatementMatched
					  |
					  WHILE LPAREN ConditionFixed RPAREN StatementMatched
					  |
					  BREAK SEMI_COMMA
					  |
					  RETURN SEMI_COMMA	
					  |
					  RETURN Expr SEMI_COMMA 
					  |
					  READ LPAREN Designator RPAREN SEMI_COMMA 
					  {: 
						  if (parser.mainMethod) parser.main_method_calls++; 
					  :}
					  |
					  PRINT LPAREN Expr RPAREN SEMI_COMMA 
					  {: 
						  if (parser.mainMethod) parser.main_method_calls++; 
					  :}
					  |
					  PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI_COMMA 
					  {: 
						  if (parser.mainMethod) parser.main_method_calls++; 
					  :}
					  |
					  LBRACE StatementList RBRACE 
					  {: 
						  parser.statement_cnt++; 
					  :};

Assignment ::= Designator EQUALS Expr SEMI_COMMA;

/***********************************************************************
     ActPars
***********************************************************************/		  

ActPars ::= Expr COMMA ActPars
			|
			Expr;	
			 
/***********************************************************************
     Condition
***********************************************************************/	  

ConditionFixed ::= Condition;

Condition ::= Condition OR CondTermFixed
			  |
			  CondTermFixed;

/***********************************************************************
     CondTerm
***********************************************************************/

CondTermFixed ::= CondTerm;

CondTerm ::= CondTerm AND CondFact
			 |
			 CondFact;

/***********************************************************************
     CondFact
***********************************************************************/

CondFact ::= Expr
			 |
			 Expr Relop Expr;

/***********************************************************************
     Expr
***********************************************************************/

Expr ::= MINUS ExprPart 
		 |
		 ExprPart;

ExprPart ::= ExprPart Addop Term
			 |
			 Term;

/***********************************************************************
     Term
***********************************************************************/

Term ::= FactorList;

FactorList ::= FactorList Mulop Factor
			   |
			   Factor;

/***********************************************************************
     Factor
***********************************************************************/

Factor ::= Designator
		   |
		   Designator:funcName LPAREN RPAREN 
		   {: 
			   if (parser.mainMethod) parser.main_method_calls++;

//			   Obj obj = currentDesignator;
//			   if (Obj.Meth == obj.getKind())
//			   {
//				   parser.report_info("Pretraga na " + funcNameleft + "(" + obj.getName() + ")" + ", nadjeno " + parser.writeObj(obj), null);
//			   }
//			   else
//				   parser.report_error("Greska na liniji " + funcNameleft + ": ime " + obj.getName() + " nije funkcija!", null);
		   :}
		   |
		   Designator:func LPAREN ActPars RPAREN  
		   {: 
			   if (parser.mainMethod) parser.main_method_calls++;
//			   if (Obj.Meth == func.getKind())
//				   parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
//			   else
//				   parser.report_error("Greska na liniji " + funcleft + ": ime " + func.getName() + " nije funkcija!", null);
			   // da li se stvarni parametri slazu sa formalnim parametrima
		   :}
		   |
		   Val
		   |
		   STRCONST
		   |
		   NEW Type:someType
		   {:
			   Obj obj = currentDesignator;
			   if (Struct.Class == someType.getKind())	// da li je klasa
			   {
				   parser.report_info("Pravljenje obj:Pretraga na " + someTypeleft + "(" + obj.getName() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   }
		   :}
		   |
		   NEW Type:someType LBRACKET Expr RBRACKET
		   {:
			   Obj obj = currentDesignator;
			   if (Struct.Class == someType.getKind())	// da li je klasa
			   {
				   parser.report_info("Pravljenje obj:Pretraga na " + someTypeleft + "(" + obj.getName() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   }
		   :}
		   |
		   LPAREN Expr RPAREN;
			
/***********************************************************************
     Designator
***********************************************************************/

Designator ::= IDENT:name DOT IDENT:namesub DesignatorList
			   {:
				   Obj obj = Tab.find(name.toString());
				   Obj subobj = Tab.noObj;
				   if(obj == Tab.noObj)
				   {
					   parser.report_error("Greska na liniji " + nameleft + ": klasa " + name.toString() + " nije deklarisana! " , null);
				   }
				   else
				   {
					   if(obj.getType().getKind() != Struct.Class)
					   {
						   parser.report_error("Greska na liniji " + nameleft + ": ocekivana klasa! " , null);
					   }
					   else
					   {
						   subobj = obj.getType().getMembersTable().searchKey(namesub.toString());
						   if(subobj == Tab.noObj)
							   parser.report_error("Greska na liniji " + namesubleft + ": ime" + namesub.toString() + " nije deklarisano! " , null);
						   else
						   {
							   // pristup polju unutrasnje klase
							   if (name.toString().equals("this"))
							   {
								   Obj prekoThis = Tab.currentScope.getOuter().findSymbol(namesub.toString());
								   if (prekoThis == Tab.noObj)
									   parser.report_error("Greska na liniji " + namesubleft + ": ime" + namesub.toString() + " nije deklarisano! " , null);
								   else
									   parser.report_info("Pristup polju:Pretraga na " + namesubleft + " (" + namesub.toString() + ")" + ", nadjeno " + parser.writeObj(prekoThis), null);
								   RESULT = prekoThis;
								   currentDesignator = prekoThis;
							   }
							   else
							   {
								   RESULT = subobj;
								   currentDesignator = subobj;
								   parser.report_info("Pristup polju:Pretraga na " + namesubleft + " (" + namesub.toString() + ")" + ", nadjeno " + parser.writeObj(subobj), null);
							   }
							   lastClass = namesubleft;
						   }
					   }
				   }  
			   :}
			   |
			   IDENT:name LBRACKET Expr RBRACKET DesignatorList
			   {:
				   Obj obj = Tab.find(name.toString());
			   	   if (obj == Tab.noObj)
			   	   {
			   		   parser.report_error("Greska na liniji " + nameleft + ": ime" + name.toString() + " nije deklarisano! " , null);
			   	   }
				   currentDesignator = obj;
				   RESULT = obj;
			   :}
			   |
			   IDENT:name
			   {:
				   Obj obj = Tab.find(name.toString());
			   	   if (obj == Tab.noObj)
			   	   {
			   		   parser.report_error("Greska na liniji " + nameleft + ": ime" + name.toString() + " nije deklarisano! " , null);
			   	   }
			   	   else
			   	   {
			   		   parser.report_info("Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   	   }
			   	   RESULT = obj;
			   	   currentDesignator = obj;
			   :};

DesignatorList ::= DesignatorList DesignatorPart
				   |
				   /* epsilon */;
			   
DesignatorPart ::= DOT IDENT:namePart
				   {:
//					   if(currentDesignator.getType().getKind() != Struct.Class)
//					   {
//						   parser.report_error("Greska na liniji " + lastClass + ": ocekivana klasa! " , null);
//					   }
					   Obj temp = RESULT;
					   Obj tempSubObj = obj.getType().getMembersTable().searchKey(namePart.toString());
					   if(tempSubObj == Tab.noObj)
						   parser.report_error("Greska na liniji " + namePartleft + ": ime" + namePart.toString() + " nije deklarisano! " , null);
					   else
					   {
						   currentDesignator = tempSubObj;
						   parser.report_info("Pristup polju:Pretraga na " + namePartleft + " (" + namePart.toString() + ")" + ", nadjeno " + parser.writeObj(tempSubObj), null);
						   lastClass = namePartleft;
					   }
					   RESULT = tempSubObj;
				   :}
	   			   |
	   			   LBRACKET Expr RBRACKET;

/***********************************************************************
     Relop
***********************************************************************/

Relop ::= EQUAL
		  |
		  NOT_EQUAL
		  |
		  GREATER
		  |
		  GREATER_OR_EQUAL
		  |
		  LESS
		  |
		  LESS_OR_EQUAL;
		  
/***********************************************************************
     Addop
***********************************************************************/		  
		  
Addop ::= PLUS
		  |
		  MINUS;	

/***********************************************************************
     Mulop
***********************************************************************/

Mulop ::= TIMES
		  |
		  DIV
		  |
		  MOD;
