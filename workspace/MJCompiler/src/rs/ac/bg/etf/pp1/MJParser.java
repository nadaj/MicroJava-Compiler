
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Feb 02 18:16:53 CET 2016
//----------------------------------------------------

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import org.apache.log4j.xml.DOMConfigurator;
import rs.ac.bg.etf.pp1.util.Log4JUtils;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.util.DumpSymbolTableVisitorModified;
import rs.etf.pp1.symboltable.structure.HashTableDataStructure;
import rs.etf.pp1.symboltable.structure.SymbolDataStructure;
import rs.etf.pp1.mj.runtime.Code;
import java.util.List;
import java.util.LinkedList;
import java.util.Collection;
import java.util.Deque;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Tue Feb 02 18:16:53 CET 2016
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\226\000\002\002\004\000\002\057\002\000\002\060" +
    "\002\000\002\067\002\000\002\070\002\000\002\071\002" +
    "\000\002\002\015\000\002\051\003\000\002\003\004\000" +
    "\002\003\002\000\002\005\003\000\002\005\003\000\002" +
    "\005\003\000\002\004\004\000\002\004\002\000\002\006" +
    "\006\000\002\013\005\000\002\013\003\000\002\012\005" +
    "\000\002\012\005\000\002\054\003\000\002\054\003\000" +
    "\002\054\003\000\002\007\005\000\002\007\005\000\002" +
    "\007\004\000\002\014\005\000\002\014\005\000\002\014" +
    "\003\000\002\015\003\000\002\015\005\000\002\072\002" +
    "\000\002\073\002\000\002\074\002\000\002\075\002\000" +
    "\002\010\016\000\002\076\002\000\002\077\002\000\002" +
    "\100\002\000\002\101\002\000\002\102\002\000\002\010" +
    "\021\000\002\055\003\000\002\061\003\000\002\016\004" +
    "\000\002\016\002\000\002\017\005\000\002\017\002\000" +
    "\002\020\004\000\002\020\002\000\002\103\002\000\002" +
    "\011\005\000\002\104\002\000\002\011\005\000\002\105" +
    "\002\000\002\106\002\000\002\107\002\000\002\110\002" +
    "\000\002\021\020\000\002\052\003\000\002\023\003\000" +
    "\002\023\002\000\002\023\005\000\002\023\003\000\002" +
    "\024\004\000\002\024\002\000\002\022\005\000\002\022" +
    "\003\000\002\026\004\000\002\026\006\000\002\056\003" +
    "\000\002\025\003\000\002\025\003\000\002\034\006\000" +
    "\002\034\012\000\002\034\006\000\002\062\002\000\002" +
    "\065\002\000\002\066\002\000\002\064\002\000\002\111" +
    "\002\000\002\063\006\000\002\035\003\000\002\112\002" +
    "\000\002\035\010\000\002\035\006\000\002\035\005\000" +
    "\002\035\005\000\002\035\012\000\002\035\006\000\002" +
    "\035\004\000\002\035\004\000\002\035\005\000\002\035" +
    "\007\000\002\035\007\000\002\035\011\000\002\035\005" +
    "\000\002\027\006\000\002\027\004\000\002\033\005\000" +
    "\002\033\003\000\002\032\003\000\002\032\003\000\002" +
    "\113\002\000\002\031\006\000\002\031\003\000\002\037" +
    "\003\000\002\036\005\000\002\036\003\000\002\040\003" +
    "\000\002\040\005\000\002\030\005\000\002\030\004\000" +
    "\002\030\003\000\002\042\003\000\002\044\005\000\002" +
    "\044\003\000\002\046\003\000\002\046\005\000\002\114" +
    "\002\000\002\046\007\000\002\046\003\000\002\046\003" +
    "\000\002\046\004\000\002\046\007\000\002\046\005\000" +
    "\002\115\002\000\002\053\007\000\002\116\002\000\002" +
    "\117\002\000\002\053\011\000\002\053\003\000\002\053" +
    "\006\000\002\047\004\000\002\047\002\000\002\120\002" +
    "\000\002\050\006\000\002\050\004\000\002\050\005\000" +
    "\002\041\003\000\002\041\003\000\002\041\003\000\002" +
    "\041\003\000\002\041\003\000\002\041\003\000\002\043" +
    "\003\000\002\043\003\000\002\045\003\000\002\045\003" +
    "\000\002\045\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\373\000\004\004\005\001\002\000\004\002\375\001" +
    "\002\000\004\005\007\001\002\000\012\005\000\006\000" +
    "\010\000\022\000\001\002\000\012\005\ufffa\006\ufffa\010" +
    "\ufffa\022\ufffa\001\002\000\012\005\ufffe\006\ufffe\010\ufffe" +
    "\022\ufffe\001\002\000\012\005\ufff8\006\ufff8\010\ufff8\022" +
    "\ufff8\001\002\000\012\005\016\006\015\010\023\022\022" +
    "\001\002\000\012\005\ufff9\006\ufff9\010\ufff9\022\ufff9\001" +
    "\002\000\006\003\362\005\363\001\002\000\010\005\ufffd" +
    "\007\ufffd\024\ufffd\001\002\000\052\003\uffbb\005\uffbb\011" +
    "\uffbb\017\uffbb\020\uffbb\021\uffbb\026\uffbb\040\uffbb\041\uffbb" +
    "\042\uffbb\045\uffbb\046\uffbb\047\uffbb\050\uffbb\051\uffbb\052" +
    "\uffbb\053\uffbb\054\uffbb\055\uffbb\056\uffbb\001\002\000\012" +
    "\005\ufff5\006\ufff5\010\ufff5\022\ufff5\001\002\000\012\005" +
    "\ufff6\006\ufff6\010\ufff6\022\ufff6\001\002\000\012\005\ufff7" +
    "\006\ufff7\010\ufff7\022\ufff7\001\002\000\004\005\042\001" +
    "\002\000\004\005\016\001\002\000\004\005\025\001\002" +
    "\000\004\012\033\001\002\000\006\011\ufff0\017\ufff0\001" +
    "\002\000\006\011\031\017\030\001\002\000\004\005\025" +
    "\001\002\000\012\005\ufff2\006\ufff2\010\ufff2\022\ufff2\001" +
    "\002\000\006\011\ufff1\017\ufff1\001\002\000\012\013\035" +
    "\014\040\015\037\016\034\001\002\000\006\011\uffee\017" +
    "\uffee\001\002\000\044\011\uffed\017\uffed\021\uffed\026\uffed" +
    "\040\uffed\041\uffed\042\uffed\045\uffed\046\uffed\047\uffed\050" +
    "\uffed\051\uffed\052\uffed\053\uffed\054\uffed\055\uffed\056\uffed" +
    "\001\002\000\006\011\uffef\017\uffef\001\002\000\044\011" +
    "\uffec\017\uffec\021\uffec\026\uffec\040\uffec\041\uffec\042\uffec" +
    "\045\uffec\046\uffec\047\uffec\050\uffec\051\uffec\052\uffec\053" +
    "\uffec\054\uffec\055\uffec\056\uffec\001\002\000\044\011\uffeb" +
    "\017\uffeb\021\uffeb\026\uffeb\040\uffeb\041\uffeb\042\uffeb\045" +
    "\uffeb\046\uffeb\047\uffeb\050\uffeb\051\uffeb\052\uffeb\053\uffeb" +
    "\054\uffeb\055\uffeb\056\uffeb\001\002\000\006\006\000\023" +
    "\043\001\002\000\006\006\uffd7\023\uffd7\001\002\000\004" +
    "\005\336\001\002\000\004\006\uffe2\001\002\000\004\006" +
    "\046\001\002\000\010\005\uffe1\006\uffe1\007\uffe1\001\002" +
    "\000\010\005\uffd4\006\uffd4\007\uffd4\001\002\000\010\005" +
    "\016\006\uffe0\007\uffe0\001\002\000\010\005\uffd5\006\uffd5" +
    "\007\uffd5\001\002\000\006\006\054\007\uffd2\001\002\000" +
    "\004\007\333\001\002\000\010\005\uffd0\007\uffd0\024\uffd0" +
    "\001\002\000\010\005\016\007\057\024\061\001\002\000" +
    "\004\005\uffcf\001\002\000\004\007\uffd3\001\002\000\010" +
    "\005\uffd1\007\uffd1\024\uffd1\001\002\000\004\005\uffcd\001" +
    "\002\000\004\005\064\001\002\000\010\005\uffcc\007\uffcc" +
    "\024\uffcc\001\002\000\004\025\uffc6\001\002\000\004\025" +
    "\000\001\002\000\004\025\uffcb\001\002\000\004\025\070" +
    "\001\002\000\010\003\072\005\016\026\uffc4\001\002\000" +
    "\004\005\326\001\002\000\006\017\324\026\uffc2\001\002" +
    "\000\006\017\322\026\uffc5\001\002\000\006\017\uffbe\026" +
    "\uffbe\001\002\000\004\026\uffca\001\002\000\004\026\077" +
    "\001\002\000\006\005\uffd4\006\uffd4\001\002\000\006\005" +
    "\016\006\101\001\002\000\026\003\uffc9\005\uffc9\006\uffc9" +
    "\007\uffc9\031\uffc9\032\uffc9\033\uffc9\034\uffc9\035\uffc9\037" +
    "\uffc9\001\002\000\026\003\uffc0\005\uffc0\006\uffc0\007\uffc0" +
    "\031\uffc0\032\uffc0\033\uffc0\034\uffc0\035\uffc0\037\uffc0\001" +
    "\002\000\026\003\116\005\110\006\106\007\121\031\113" +
    "\032\107\033\122\034\120\035\104\037\117\001\002\000" +
    "\004\025\316\001\002\000\030\003\uffaf\005\uffaf\006\uffaf" +
    "\007\uffaf\031\uffaf\032\uffaf\033\uffaf\034\uffaf\035\uffaf\036" +
    "\uffaf\037\uffaf\001\002\000\026\003\uffc0\005\uffc0\006\uffc0" +
    "\007\uffc0\031\uffc0\032\uffc0\033\uffc0\034\uffc0\035\uffc0\037" +
    "\uffc0\001\002\000\004\025\uffb5\001\002\000\060\011\uff7e" +
    "\012\uff7e\017\uff7e\020\263\021\uff7e\025\uff7e\026\uff7e\027" +
    "\uff7e\030\uff7e\040\uff7e\041\uff7e\042\uff7e\044\264\045\uff7e" +
    "\046\uff7e\047\uff7e\050\uff7e\051\uff7e\052\uff7e\053\uff7e\054" +
    "\uff7e\055\uff7e\056\uff7e\001\002\000\012\012\245\025\250" +
    "\027\246\030\247\001\002\000\026\003\uffb9\005\uffb9\006" +
    "\uffb9\007\uffb9\031\uffb9\032\uffb9\033\uffb9\034\uffb9\035\uffb9" +
    "\037\uffb9\001\002\000\004\025\204\001\002\000\026\003" +
    "\uffc1\005\uffc1\006\uffc1\007\uffc1\031\uffc1\032\uffc1\033\uffc1" +
    "\034\uffc1\035\uffc1\037\uffc1\001\002\000\026\003\uffba\005" +
    "\uffba\006\uffba\007\uffba\031\uffba\032\uffba\033\uffba\034\uffba" +
    "\035\uffba\037\uffba\001\002\000\004\011\202\001\002\000" +
    "\004\025\172\001\002\000\024\005\110\011\133\013\035" +
    "\014\040\015\037\016\136\025\137\042\126\043\130\001" +
    "\002\000\010\005\uffc8\007\uffc8\024\uffc8\001\002\000\004" +
    "\011\123\001\002\000\030\003\uffa7\005\uffa7\006\uffa7\007" +
    "\uffa7\031\uffa7\032\uffa7\033\uffa7\034\uffa7\035\uffa7\036\uffa7" +
    "\037\uffa7\001\002\000\010\005\uffff\007\uffff\024\uffff\001" +
    "\002\000\010\005\uffc7\007\uffc7\024\uffc7\001\002\000\020" +
    "\005\110\013\035\014\040\015\037\016\136\025\137\043" +
    "\130\001\002\000\010\011\170\042\151\053\150\001\002" +
    "\000\004\005\016\001\002\000\046\011\uff8c\017\uff8c\021" +
    "\uff8c\025\154\026\uff8c\040\uff8c\041\uff8c\042\uff8c\045\uff8c" +
    "\046\uff8c\047\uff8c\050\uff8c\051\uff8c\052\uff8c\053\uff8c\054" +
    "\uff8c\055\uff8c\056\uff8c\001\002\000\044\011\uff88\017\uff88" +
    "\021\uff88\026\uff88\040\uff88\041\uff88\042\uff88\045\uff88\046" +
    "\uff88\047\uff88\050\uff88\051\uff88\052\uff88\053\uff88\054\uff88" +
    "\055\uff88\056\uff88\001\002\000\030\003\uffa6\005\uffa6\006" +
    "\uffa6\007\uffa6\031\uffa6\032\uffa6\033\uffa6\034\uffa6\035\uffa6" +
    "\036\uffa6\037\uffa6\001\002\000\036\011\uff90\017\uff90\021" +
    "\uff90\026\uff90\040\uff90\041\uff90\042\uff90\045\uff90\046\uff90" +
    "\047\uff90\050\uff90\051\uff90\052\uff90\053\uff90\001\002\000" +
    "\044\011\uff8d\017\uff8d\021\uff8d\026\uff8d\040\uff8d\041\uff8d" +
    "\042\uff8d\045\uff8d\046\uff8d\047\uff8d\050\uff8d\051\uff8d\052" +
    "\uff8d\053\uff8d\054\uff8d\055\uff8d\056\uff8d\001\002\000\044" +
    "\011\uff87\017\uff87\021\uff87\026\uff87\040\uff87\041\uff87\042" +
    "\uff87\045\uff87\046\uff87\047\uff87\050\uff87\051\uff87\052\uff87" +
    "\053\uff87\054\uff87\055\uff87\056\uff87\001\002\000\022\005" +
    "\110\013\035\014\040\015\037\016\136\025\137\042\126" +
    "\043\130\001\002\000\044\011\uff8f\017\uff8f\021\uff8f\026" +
    "\uff8f\040\uff8f\041\uff8f\042\uff8f\045\uff8f\046\uff8f\047\uff8f" +
    "\050\uff8f\051\uff8f\052\uff8f\053\uff8f\054\144\055\142\056" +
    "\141\001\002\000\020\005\uff6c\013\uff6c\014\uff6c\015\uff6c" +
    "\016\uff6c\025\uff6c\043\uff6c\001\002\000\020\005\uff6d\013" +
    "\uff6d\014\uff6d\015\uff6d\016\uff6d\025\uff6d\043\uff6d\001\002" +
    "\000\020\005\110\013\035\014\040\015\037\016\136\025" +
    "\137\043\130\001\002\000\020\005\uff6e\013\uff6e\014\uff6e" +
    "\015\uff6e\016\uff6e\025\uff6e\043\uff6e\001\002\000\044\011" +
    "\uff8e\017\uff8e\021\uff8e\026\uff8e\040\uff8e\041\uff8e\042\uff8e" +
    "\045\uff8e\046\uff8e\047\uff8e\050\uff8e\051\uff8e\052\uff8e\053" +
    "\uff8e\054\uff8e\055\uff8e\056\uff8e\001\002\000\010\026\147" +
    "\042\151\053\150\001\002\000\044\011\uff84\017\uff84\021" +
    "\uff84\026\uff84\040\uff84\041\uff84\042\uff84\045\uff84\046\uff84" +
    "\047\uff84\050\uff84\051\uff84\052\uff84\053\uff84\054\uff84\055" +
    "\uff84\056\uff84\001\002\000\020\005\uff70\013\uff70\014\uff70" +
    "\015\uff70\016\uff70\025\uff70\043\uff70\001\002\000\020\005" +
    "\uff6f\013\uff6f\014\uff6f\015\uff6f\016\uff6f\025\uff6f\043\uff6f" +
    "\001\002\000\020\005\110\013\035\014\040\015\037\016" +
    "\136\025\137\043\130\001\002\000\036\011\uff92\017\uff92" +
    "\021\uff92\026\uff92\040\uff92\041\uff92\042\uff92\045\uff92\046" +
    "\uff92\047\uff92\050\uff92\051\uff92\052\uff92\053\uff92\001\002" +
    "\000\024\005\uff8a\013\uff8a\014\uff8a\015\uff8a\016\uff8a\025" +
    "\uff8a\026\156\042\uff8a\043\uff8a\001\002\000\022\005\110" +
    "\013\035\014\040\015\037\016\136\025\137\042\126\043" +
    "\130\001\002\000\044\011\uff8b\017\uff8b\021\uff8b\026\uff8b" +
    "\040\uff8b\041\uff8b\042\uff8b\045\uff8b\046\uff8b\047\uff8b\050" +
    "\uff8b\051\uff8b\052\uff8b\053\uff8b\054\uff8b\055\uff8b\056\uff8b" +
    "\001\002\000\004\026\163\001\002\000\012\017\161\026" +
    "\uff9d\042\151\053\150\001\002\000\022\005\110\013\035" +
    "\014\040\015\037\016\136\025\137\042\126\043\130\001" +
    "\002\000\004\026\uff9e\001\002\000\044\011\uff89\017\uff89" +
    "\021\uff89\026\uff89\040\uff89\041\uff89\042\uff89\045\uff89\046" +
    "\uff89\047\uff89\050\uff89\051\uff89\052\uff89\053\uff89\054\uff89" +
    "\055\uff89\056\uff89\001\002\000\046\011\uff86\017\uff86\020" +
    "\165\021\uff86\026\uff86\040\uff86\041\uff86\042\uff86\045\uff86" +
    "\046\uff86\047\uff86\050\uff86\051\uff86\052\uff86\053\uff86\054" +
    "\uff86\055\uff86\056\uff86\001\002\000\022\005\110\013\035" +
    "\014\040\015\037\016\136\025\137\042\126\043\130\001" +
    "\002\000\010\021\167\042\151\053\150\001\002\000\044" +
    "\011\uff85\017\uff85\021\uff85\026\uff85\040\uff85\041\uff85\042" +
    "\uff85\045\uff85\046\uff85\047\uff85\050\uff85\051\uff85\052\uff85" +
    "\053\uff85\054\uff85\055\uff85\056\uff85\001\002\000\030\003" +
    "\uffa5\005\uffa5\006\uffa5\007\uffa5\031\uffa5\032\uffa5\033\uffa5" +
    "\034\uffa5\035\uffa5\036\uffa5\037\uffa5\001\002\000\036\011" +
    "\uff91\017\uff91\021\uff91\026\uff91\040\uff91\041\uff91\042\uff91" +
    "\045\uff91\046\uff91\047\uff91\050\uff91\051\uff91\052\uff91\053" +
    "\uff91\001\002\000\022\005\110\013\035\014\040\015\037" +
    "\016\136\025\137\042\126\043\130\001\002\000\012\017" +
    "\174\026\175\042\151\053\150\001\002\000\004\013\177" +
    "\001\002\000\004\011\176\001\002\000\030\003\uffa3\005" +
    "\uffa3\006\uffa3\007\uffa3\031\uffa3\032\uffa3\033\uffa3\034\uffa3" +
    "\035\uffa3\036\uffa3\037\uffa3\001\002\000\004\026\200\001" +
    "\002\000\004\011\201\001\002\000\030\003\uffa2\005\uffa2" +
    "\006\uffa2\007\uffa2\031\uffa2\032\uffa2\033\uffa2\034\uffa2\035" +
    "\uffa2\036\uffa2\037\uffa2\001\002\000\030\003\uff9f\005\uff9f" +
    "\006\uff9f\007\uff9f\031\uff9f\032\uff9f\033\uff9f\034\uff9f\035" +
    "\uff9f\036\uff9f\037\uff9f\001\002\000\024\003\116\005\110" +
    "\006\106\031\113\032\107\033\122\034\120\035\104\037" +
    "\117\001\002\000\024\003\uffb1\005\uffb1\013\uffb1\014\uffb1" +
    "\015\uffb1\016\uffb1\025\uffb1\042\uffb1\043\uffb1\001\002\000" +
    "\024\003\211\005\110\013\035\014\040\015\037\016\136" +
    "\025\137\042\126\043\130\001\002\000\010\026\uff95\040" +
    "\uff95\041\uff95\001\002\000\030\026\uff94\040\uff94\041\uff94" +
    "\042\151\045\225\046\231\047\224\050\227\051\230\052" +
    "\223\053\150\001\002\000\004\026\222\001\002\000\004" +
    "\026\uff9b\001\002\000\006\026\uff98\040\uff98\001\002\000" +
    "\010\026\uff97\040\uff97\041\220\001\002\000\006\026\uff9c" +
    "\040\uff9a\001\002\000\004\040\216\001\002\000\022\005" +
    "\110\013\035\014\040\015\037\016\136\025\137\042\126" +
    "\043\130\001\002\000\006\026\uff99\040\uff99\001\002\000" +
    "\022\005\110\013\035\014\040\015\037\016\136\025\137" +
    "\042\126\043\130\001\002\000\010\026\uff96\040\uff96\041" +
    "\uff96\001\002\000\024\003\uffb0\005\uffb0\006\uffb0\031\uffb0" +
    "\032\uffb0\033\uffb0\034\uffb0\035\uffb0\037\uffb0\001\002\000" +
    "\022\005\uff71\013\uff71\014\uff71\015\uff71\016\uff71\025\uff71" +
    "\042\uff71\043\uff71\001\002\000\022\005\uff74\013\uff74\014" +
    "\uff74\015\uff74\016\uff74\025\uff74\042\uff74\043\uff74\001\002" +
    "\000\022\005\uff76\013\uff76\014\uff76\015\uff76\016\uff76\025" +
    "\uff76\042\uff76\043\uff76\001\002\000\022\005\110\013\035" +
    "\014\040\015\037\016\136\025\137\042\126\043\130\001" +
    "\002\000\022\005\uff73\013\uff73\014\uff73\015\uff73\016\uff73" +
    "\025\uff73\042\uff73\043\uff73\001\002\000\022\005\uff72\013" +
    "\uff72\014\uff72\015\uff72\016\uff72\025\uff72\042\uff72\043\uff72" +
    "\001\002\000\022\005\uff75\013\uff75\014\uff75\015\uff75\016" +
    "\uff75\025\uff75\042\uff75\043\uff75\001\002\000\014\026\uff93" +
    "\040\uff93\041\uff93\042\151\053\150\001\002\000\030\003" +
    "\uffb9\005\uffb9\006\uffb9\007\uffb9\031\uffb9\032\uffb9\033\uffb9" +
    "\034\uffb9\035\uffb9\036\uffb4\037\uffb9\001\002\000\026\003" +
    "\uffb2\005\uffb2\006\uffb2\007\uffb2\031\uffb2\032\uffb2\033\uffb2" +
    "\034\uffb2\035\uffb2\037\uffb2\001\002\000\026\003\uffb8\005" +
    "\uffb8\006\uffb8\007\uffb8\031\uffb8\032\uffb8\033\uffb8\034\uffb8" +
    "\035\uffb8\037\uffb8\001\002\000\004\036\237\001\002\000" +
    "\024\003\uffb2\005\uffb2\006\uffb2\031\uffb2\032\uffb2\033\uffb2" +
    "\034\uffb2\035\uffb2\037\uffb2\001\002\000\024\003\116\005" +
    "\110\006\106\031\113\032\107\033\122\034\120\035\104" +
    "\037\117\001\002\000\030\003\uffb3\005\uffb3\006\uffb3\007" +
    "\uffb3\031\uffb3\032\uffb3\033\uffb3\034\uffb3\035\uffb3\036\uffb3" +
    "\037\uffb3\001\002\000\026\003\uffb3\005\uffb3\006\uffb3\007" +
    "\uffb3\031\uffb3\032\uffb3\033\uffb3\034\uffb3\035\uffb3\037\uffb3" +
    "\001\002\000\026\003\uffb7\005\uffb7\006\uffb7\007\uffb7\031" +
    "\uffb7\032\uffb7\033\uffb7\034\uffb7\035\uffb7\037\uffb7\001\002" +
    "\000\030\003\uffa9\005\uffa9\006\uffa9\007\uffa9\031\uffa9\032" +
    "\uffa9\033\uffa9\034\uffa9\035\uffa9\036\uffa9\037\uffa9\001\002" +
    "\000\022\005\110\013\035\014\040\015\037\016\136\025" +
    "\137\042\126\043\130\001\002\000\004\011\260\001\002" +
    "\000\004\011\257\001\002\000\024\005\uffae\013\uffae\014" +
    "\uffae\015\uffae\016\uffae\025\uffae\026\251\042\uffae\043\uffae" +
    "\001\002\000\004\011\256\001\002\000\022\005\110\013" +
    "\035\014\040\015\037\016\136\025\137\042\126\043\130" +
    "\001\002\000\004\026\254\001\002\000\004\011\255\001" +
    "\002\000\030\003\uffad\005\uffad\006\uffad\007\uffad\031\uffad" +
    "\032\uffad\033\uffad\034\uffad\035\uffad\036\uffad\037\uffad\001" +
    "\002\000\030\003\uffac\005\uffac\006\uffac\007\uffac\031\uffac" +
    "\032\uffac\033\uffac\034\uffac\035\uffac\036\uffac\037\uffac\001" +
    "\002\000\030\003\uffaa\005\uffaa\006\uffaa\007\uffaa\031\uffaa" +
    "\032\uffaa\033\uffaa\034\uffaa\035\uffaa\036\uffaa\037\uffaa\001" +
    "\002\000\030\003\uffab\005\uffab\006\uffab\007\uffab\031\uffab" +
    "\032\uffab\033\uffab\034\uffab\035\uffab\036\uffab\037\uffab\001" +
    "\002\000\010\011\262\042\151\053\150\001\002\000\030" +
    "\003\uffa0\005\uffa0\006\uffa0\007\uffa0\031\uffa0\032\uffa0\033" +
    "\uffa0\034\uffa0\035\uffa0\036\uffa0\037\uffa0\001\002\000\024" +
    "\003\301\005\uff81\013\uff81\014\uff81\015\uff81\016\uff81\025" +
    "\uff81\042\uff81\043\uff81\001\002\000\004\005\265\001\002" +
    "\000\060\011\uff83\012\uff83\017\uff83\020\uff83\021\uff83\025" +
    "\uff83\026\uff83\027\uff83\030\uff83\040\uff83\041\uff83\042\uff83" +
    "\044\uff83\045\uff83\046\uff83\047\uff83\050\uff83\051\uff83\052" +
    "\uff83\053\uff83\054\uff83\055\uff83\056\uff83\001\002\000\060" +
    "\011\uff7b\012\uff7b\017\uff7b\020\uff7b\021\uff7b\025\uff7b\026" +
    "\uff7b\027\uff7b\030\uff7b\040\uff7b\041\uff7b\042\uff7b\044\uff7b" +
    "\045\uff7b\046\uff7b\047\uff7b\050\uff7b\051\uff7b\052\uff7b\053" +
    "\uff7b\054\uff7b\055\uff7b\056\uff7b\001\002\000\060\011\uff82" +
    "\012\uff82\017\uff82\020\271\021\uff82\025\uff82\026\uff82\027" +
    "\uff82\030\uff82\040\uff82\041\uff82\042\uff82\044\272\045\uff82" +
    "\046\uff82\047\uff82\050\uff82\051\uff82\052\uff82\053\uff82\054" +
    "\uff82\055\uff82\056\uff82\001\002\000\060\011\uff7c\012\uff7c" +
    "\017\uff7c\020\uff7c\021\uff7c\025\uff7c\026\uff7c\027\uff7c\030" +
    "\uff7c\040\uff7c\041\uff7c\042\uff7c\044\uff7c\045\uff7c\046\uff7c" +
    "\047\uff7c\050\uff7c\051\uff7c\052\uff7c\053\uff7c\054\uff7c\055" +
    "\uff7c\056\uff7c\001\002\000\024\003\274\005\uff7a\013\uff7a" +
    "\014\uff7a\015\uff7a\016\uff7a\025\uff7a\042\uff7a\043\uff7a\001" +
    "\002\000\004\005\273\001\002\000\060\011\uff78\012\uff78" +
    "\017\uff78\020\uff78\021\uff78\025\uff78\026\uff78\027\uff78\030" +
    "\uff78\040\uff78\041\uff78\042\uff78\044\uff78\045\uff78\046\uff78" +
    "\047\uff78\050\uff78\051\uff78\052\uff78\053\uff78\054\uff78\055" +
    "\uff78\056\uff78\001\002\000\004\021\300\001\002\000\022" +
    "\005\110\013\035\014\040\015\037\016\136\025\137\042" +
    "\126\043\130\001\002\000\010\021\277\042\151\053\150" +
    "\001\002\000\060\011\uff79\012\uff79\017\uff79\020\uff79\021" +
    "\uff79\025\uff79\026\uff79\027\uff79\030\uff79\040\uff79\041\uff79" +
    "\042\uff79\044\uff79\045\uff79\046\uff79\047\uff79\050\uff79\051" +
    "\uff79\052\uff79\053\uff79\054\uff79\055\uff79\056\uff79\001\002" +
    "\000\060\011\uff77\012\uff77\017\uff77\020\uff77\021\uff77\025" +
    "\uff77\026\uff77\027\uff77\030\uff77\040\uff77\041\uff77\042\uff77" +
    "\044\uff77\045\uff77\046\uff77\047\uff77\050\uff77\051\uff77\052" +
    "\uff77\053\uff77\054\uff77\055\uff77\056\uff77\001\002\000\004" +
    "\021\307\001\002\000\022\005\110\013\035\014\040\015" +
    "\037\016\136\025\137\042\126\043\130\001\002\000\010" +
    "\021\304\042\151\053\150\001\002\000\060\011\uff80\012" +
    "\uff80\017\uff80\020\uff80\021\uff80\025\uff80\026\uff80\027\uff80" +
    "\030\uff80\040\uff80\041\uff80\042\uff80\044\uff80\045\uff80\046" +
    "\uff80\047\uff80\050\uff80\051\uff80\052\uff80\053\uff80\054\uff80" +
    "\055\uff80\056\uff80\001\002\000\060\011\uff7b\012\uff7b\017" +
    "\uff7b\020\uff7b\021\uff7b\025\uff7b\026\uff7b\027\uff7b\030\uff7b" +
    "\040\uff7b\041\uff7b\042\uff7b\044\uff7b\045\uff7b\046\uff7b\047" +
    "\uff7b\050\uff7b\051\uff7b\052\uff7b\053\uff7b\054\uff7b\055\uff7b" +
    "\056\uff7b\001\002\000\060\011\uff7f\012\uff7f\017\uff7f\020" +
    "\271\021\uff7f\025\uff7f\026\uff7f\027\uff7f\030\uff7f\040\uff7f" +
    "\041\uff7f\042\uff7f\044\272\045\uff7f\046\uff7f\047\uff7f\050" +
    "\uff7f\051\uff7f\052\uff7f\053\uff7f\054\uff7f\055\uff7f\056\uff7f" +
    "\001\002\000\054\011\uff7d\012\uff7d\017\uff7d\021\uff7d\025" +
    "\uff7d\026\uff7d\027\uff7d\030\uff7d\040\uff7d\041\uff7d\042\uff7d" +
    "\045\uff7d\046\uff7d\047\uff7d\050\uff7d\051\uff7d\052\uff7d\053" +
    "\uff7d\054\uff7d\055\uff7d\056\uff7d\001\002\000\004\025\204" +
    "\001\002\000\024\003\116\005\110\006\106\031\113\032" +
    "\107\033\122\034\120\035\104\037\117\001\002\000\030" +
    "\003\uffa8\005\uffa8\006\uffa8\007\uffa8\031\uffa8\032\uffa8\033" +
    "\uffa8\034\uffa8\035\uffa8\036\uffa8\037\uffa8\001\002\000\026" +
    "\003\uffb6\005\uffb6\006\uffb6\007\uffb6\031\uffb6\032\uffb6\033" +
    "\uffb6\034\uffb6\035\uffb6\037\uffb6\001\002\000\026\003\116" +
    "\005\110\006\106\007\315\031\113\032\107\033\122\034" +
    "\120\035\104\037\117\001\002\000\030\003\uffa1\005\uffa1" +
    "\006\uffa1\007\uffa1\031\uffa1\032\uffa1\033\uffa1\034\uffa1\035" +
    "\uffa1\036\uffa1\037\uffa1\001\002\000\004\005\110\001\002" +
    "\000\004\026\320\001\002\000\004\011\321\001\002\000" +
    "\030\003\uffa4\005\uffa4\006\uffa4\007\uffa4\031\uffa4\032\uffa4" +
    "\033\uffa4\034\uffa4\035\uffa4\036\uffa4\037\uffa4\001\002\000" +
    "\004\005\016\001\002\000\006\017\uffbf\026\uffbf\001\002" +
    "\000\004\005\016\001\002\000\006\017\322\026\uffc3\001" +
    "\002\000\010\017\uffbd\020\327\026\uffbd\001\002\000\004" +
    "\021\330\001\002\000\006\017\uffbc\026\uffbc\001\002\000" +
    "\004\005\064\001\002\000\010\005\uffce\007\uffce\024\uffce" +
    "\001\002\000\012\005\uffdf\006\uffdf\010\uffdf\022\uffdf\001" +
    "\002\000\012\005\uffff\006\uffff\010\uffff\022\uffff\001\002" +
    "\000\012\005\uffde\006\uffde\010\uffde\022\uffde\001\002\000" +
    "\004\006\uffd6\001\002\000\004\006\uffdd\001\002\000\004" +
    "\006\000\001\002\000\004\006\uffdc\001\002\000\004\006" +
    "\343\001\002\000\010\005\uffdb\006\uffdb\007\uffdb\001\002" +
    "\000\010\005\uffd4\006\uffd4\007\uffd4\001\002\000\010\005" +
    "\016\006\uffda\007\uffda\001\002\000\006\006\054\007\uffd2" +
    "\001\002\000\004\007\350\001\002\000\012\005\uffd9\006" +
    "\uffd9\010\uffd9\022\uffd9\001\002\000\012\005\uffff\006\uffff" +
    "\010\uffff\022\uffff\001\002\000\012\005\uffd8\006\uffd8\010" +
    "\uffd8\022\uffd8\001\002\000\010\005\ufff3\007\ufff3\024\ufff3" +
    "\001\002\000\010\005\016\007\355\024\061\001\002\000" +
    "\004\002\ufffc\001\002\000\010\005\ufff4\007\ufff4\024\ufff4" +
    "\001\002\000\004\002\uffff\001\002\000\004\002\ufffb\001" +
    "\002\000\006\011\373\017\372\001\002\000\020\005\uffe8" +
    "\006\uffe8\007\uffe8\010\uffe8\011\370\017\367\022\uffe8\001" +
    "\002\000\010\011\uffe4\017\uffe4\020\365\001\002\000\006" +
    "\011\uffe5\017\uffe5\001\002\000\004\021\366\001\002\000" +
    "\006\011\uffe3\017\uffe3\001\002\000\004\005\363\001\002" +
    "\000\014\005\uffe9\006\uffe9\007\uffe9\010\uffe9\022\uffe9\001" +
    "\002\000\006\011\uffe6\017\uffe6\001\002\000\004\005\363" +
    "\001\002\000\014\005\uffea\006\uffea\007\uffea\010\uffea\022" +
    "\uffea\001\002\000\006\011\uffe7\017\uffe7\001\002\000\004" +
    "\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\373\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\051\005\001\001\000\004\057\007\001\001\000\002" +
    "\001\001\000\004\067\010\001\001\000\004\003\011\001" +
    "\001\000\014\005\012\006\020\007\017\010\016\056\013" +
    "\001\001\000\002\001\001\000\006\014\360\015\363\001" +
    "\001\000\004\070\352\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\055" +
    "\040\001\001\000\004\056\023\001\001\000\006\012\025" +
    "\013\026\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\012\031\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\054\035\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\057\043\001\001\000\002\001" +
    "\001\000\004\061\336\001\001\000\004\072\044\001\001" +
    "\000\002\001\001\000\004\073\046\001\001\000\004\016" +
    "\047\001\001\000\010\007\050\056\013\074\051\001\001" +
    "\000\002\001\001\000\004\017\052\001\001\000\002\001" +
    "\001\000\004\020\054\001\001\000\006\011\057\056\055" +
    "\001\001\000\004\103\330\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\104\061\001\001\000\006\021\062" +
    "\052\064\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\057\065\001\001\000\004\105\066\001\001\000\002" +
    "\001\001\000\012\022\072\023\074\026\073\056\070\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\106\075\001\001\000\002\001" +
    "\001\000\004\016\077\001\001\000\006\007\050\056\013" +
    "\001\001\000\004\107\101\001\001\000\004\024\102\001" +
    "\001\000\014\025\113\027\104\034\114\035\111\053\110" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\024" +
    "\313\001\001\000\004\062\307\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\063\202\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\030\126\042\133\044\137\046" +
    "\134\053\130\054\131\001\001\000\004\110\123\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\060\124\001" +
    "\001\000\002\001\001\000\014\042\170\044\137\046\134" +
    "\053\130\054\131\001\001\000\004\043\151\001\001\000" +
    "\004\056\163\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\016\030\145\042\133\044\137\046\134" +
    "\053\130\054\131\001\001\000\004\045\142\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\046\144\053\130" +
    "\054\131\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\043\151\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\042\152\044\137\046\134\053" +
    "\130\054\131\001\001\000\002\001\001\000\004\114\154" +
    "\001\001\000\020\030\157\033\156\042\133\044\137\046" +
    "\134\053\130\054\131\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\043\151\001\001\000\020\030\157\033" +
    "\161\042\133\044\137\046\134\053\130\054\131\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\030\165\042\133\044\137\046\134\053\130\054\131" +
    "\001\001\000\004\043\151\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\030\172\042\133" +
    "\044\137\046\134\053\130\054\131\001\001\000\004\043" +
    "\151\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\025\233\027\104\034\114" +
    "\035\232\053\110\001\001\000\004\111\204\001\001\000" +
    "\030\030\206\031\213\032\207\036\212\037\211\040\205" +
    "\042\133\044\137\046\134\053\130\054\131\001\001\000" +
    "\002\001\001\000\006\041\225\043\151\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\113\214\001\001\000\002\001\001\000\024" +
    "\030\206\036\212\037\216\040\205\042\133\044\137\046" +
    "\134\053\130\054\131\001\001\000\002\001\001\000\020" +
    "\030\206\040\220\042\133\044\137\046\134\053\130\054" +
    "\131\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\016\030" +
    "\231\042\133\044\137\046\134\053\130\054\131\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\043\151\001\001\000\004\065\235\001\001\000\004" +
    "\064\234\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\064\237\001\001\000\012\027\104\034\241\035\240" +
    "\053\110\001\001\000\004\066\243\001\001\000\004\066" +
    "\242\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\030\260\042\133\044\137\046\134\053\130\054\131\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\112\251" +
    "\001\001\000\002\001\001\000\020\030\157\033\252\042" +
    "\133\044\137\046\134\053\130\054\131\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\043\151" +
    "\001\001\000\002\001\001\000\004\116\301\001\001\000" +
    "\002\001\001\000\004\115\265\001\001\000\004\047\266" +
    "\001\001\000\004\050\267\001\001\000\002\001\001\000" +
    "\004\120\274\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\016\030\275\042\133\044\137\046" +
    "\134\053\130\054\131\001\001\000\004\043\151\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\030\302\042\133\044\137\046\134\053\130\054\131" +
    "\001\001\000\004\043\151\001\001\000\004\117\304\001" +
    "\001\000\004\047\305\001\001\000\004\050\267\001\001" +
    "\000\002\001\001\000\004\063\310\001\001\000\012\027" +
    "\104\034\312\035\311\053\110\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\025\113\027\104\034\114\035" +
    "\111\053\110\001\001\000\002\001\001\000\004\053\316" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\026\322\056\070\001\001\000\002\001\001" +
    "\000\010\022\324\026\073\056\070\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\021\331\052\064\001\001\000\002\001\001\000" +
    "\004\075\333\001\001\000\004\060\334\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\076\337\001\001\000" +
    "\004\057\340\001\001\000\004\077\341\001\001\000\002" +
    "\001\001\000\004\100\343\001\001\000\004\016\344\001" +
    "\001\000\010\007\050\056\013\101\345\001\001\000\004" +
    "\017\346\001\001\000\002\001\001\000\004\102\350\001" +
    "\001\000\004\060\351\001\001\000\002\001\001\000\004" +
    "\004\353\001\001\000\006\011\355\056\055\001\001\000" +
    "\004\071\356\001\001\000\002\001\001\000\004\060\357" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\015\370\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\015\373\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
	
	Tab.init();					// Universe scope	

	Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool", CUP$MJParser$actions.boolType));
	Tab.currentScope.addToLocals(new Obj(Obj.Type, "string", CUP$MJParser$actions.stringType));
	
	errorFound = false;
	mainMethod = false;
	isGlobal = true;
	inner = false;
	local = false;
	mismatched = false;
	wrongReturnTypeOverride = false;
	
	var_count = 0;
	main_var_count = 0;
	const_count = 0;
   	array_count = 0;
   	function_cnt = 0;
   	statement_cnt = 0;
   	main_method_calls = 0;
   	formal_param_cnt = 0;
   	inner_class_cnt = 0;
   	inner_class_meth_cnt = 0;
   	inner_class_field_cnt = 0;

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		System.out.println(s.toString() + " " + s.value.toString());
	return s;

    }


	
	static {
		DOMConfigurator.configure(Log4JUtils.instance().findLoggerConfigFile());
		Log4JUtils.instance().prepareLogFile(Logger.getRootLogger());
	}
	
	public boolean errorFound = false;
	public boolean isGlobal = true;				// globalne prom
	public boolean mainMethod = false;			// da li je main metoda glavne klase
	public boolean inner = false;				// unutrasnje klase
	public boolean local = false;				// koristim za polja unutrasnjih klasa
	public boolean mismatched = false;			// override
	public boolean wrongReturnTypeOverride = false;
	
	// BROJACI ZA NIVO A
   	public int var_count = 0;
	public int main_var_count = 0;
	public int const_count = 0;
   	public int array_count = 0;
   	
   	// BROJACI ZA NIVO B	
   	public int function_cnt = 0;
   	public int statement_cnt = 0;
   	public int main_method_calls = 0;
   	public int formal_param_cnt = 0;
   	
   	// BROJACI ZA NIVO C
	public int inner_class_cnt = 0;
	public int inner_class_meth_cnt = 0;
	public int inner_class_field_cnt = 0;
   	
	public static void main(String[] args) throws Exception {
		Logger log = Logger.getLogger(MJParser.class);	
		Reader br = null;
		
		try {
			if (args.length < 1) {
				log.error("Not enough arguments supplied! Usage: MJParser <source-file>");
				return;
			}
			
			File sourceCode = new File(args[0]);
			if (!sourceCode.exists()) {
				log.error("Source file [" + sourceCode.getAbsolutePath() + "] not found!");
				return;
			}
				
			log.info("Compiling source file: " + sourceCode.getAbsolutePath());
			
			br = new BufferedReader(new FileReader(sourceCode));
			Yylex lexer = new Yylex(br);
			
			MJParser p = new MJParser(lexer);
	        Symbol s = p.parse();  //pocetak parsiranja
	        
	        /*
	         * ISPIS SADRZAJA TABELE SIMBOLA
	         */
	        DumpSymbolTableVisitorModified ds = new DumpSymbolTableVisitorModified();
	        Tab.dump(ds);
	        
	        if (p.errorFound) {
	        	log.error("Parsiranje nije uspesno zavrseno!");
	        }
	        else {
	        	// GENERISANJE KODA
	        	File objFile = new File(("test/program.obj"));
	        	if (objFile.exists())
	        		objFile.delete();
	        	Code.write(new FileOutputStream(objFile));
	        	
	        	System.out.println("=====================SINTAKSNA ANALIZA=========================");
	        	System.out.println(p.var_count + "\tglobalne promenljive" );
			   	System.out.println(p.main_var_count + "\tlokalne promenljive (u main funkciji)");
			   	System.out.println(p.const_count + "\tglobalne konstante");
			   	System.out.println(p.array_count + "\tglobalni nizovi");
			   	
				System.out.println(p.function_cnt + "\tfunkcije u glavnom programu");
				System.out.println(p.statement_cnt + "\tblokovi naredbi");
				System.out.println(p.main_method_calls + "\tpozivi funkcija u telu metode main");
				System.out.println(p.formal_param_cnt + "\tformalni argumenti funkcija");
			   	
				System.out.println(p.inner_class_cnt + "\tunutrasnje klase");
				System.out.println(p.inner_class_meth_cnt + "\tmetode unutrasnjih klasa");
				System.out.println(p.inner_class_field_cnt + "\tpolja unutrasnjih klasa");
	        	System.out.println("\nParsiranje je uspesno zavrseno!");
	        }
	        
		} 
		finally {
			if (br != null) try { br.close(); } catch (IOException e1) { log.error(e1.getMessage(), e1); }
		}
	}
	
	Logger log = Logger.getLogger(getClass());
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
	
	// ovde se moze izvrsiti oporavak
	public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
	
	// ovde se ne moze izvrsiti oporavak
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }
	
	public void report_error(String message, Object info){
		errorFound = true;
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
	      	msg.append(" na liniji ").append(((Symbol)info).left);
	    log.error(message);
    }
	
	public void report_info(String message, Object info){
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
	      	msg.append(" na liniji ").append(((Symbol)info).left);
		System.out.println(message);
    }
	
	public String writeObj(Obj obj)
	{
		String message = "";
		if (obj != null)
		{
			DumpSymbolTableVisitorModified ds = new DumpSymbolTableVisitorModified();
			obj.accept(ds);
			message = ds.getOutput();
		}
		return message;
	}
	

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {

  
	Logger log = Logger.getLogger(getClass());

	public static final Struct boolType = new Struct(Struct.Bool);
	
	public static final Struct stringType = new Struct(6);
	
	Obj currentMethod = null, currentClass = null, currentDesignator = null, baseClass = null, overridenMethod = null;
	Obj arrayType = null, currentCalledFunc = null;
	Struct currentType = Tab.noType, methReturnType;
	int lastClass = 0;
	boolean isVoid = false, returnExists=false;	// za kontekstni uslov (return)
	boolean hasDes = false;			
	int numBrack = 0, numWhile = 0, lastVisitedParam;
	boolean mainDetected = false;
	Obj currentIndex = null;
	Obj theArr = null;
	Obj currentTypeObj = null;
	Obj strC = null;
	
	int printStringAdr = 0;
	int printStringAdrWithLength = 0;
	int readStringAdr = 0;
	int catStrAdr = 0;
	int eqStrAdr = 0;
	
	MethodTable methodTable = new MethodTable();
	Deque<ArrayList<Integer>> falseAdrFixS = new ArrayDeque<ArrayList<Integer>>();
	Deque<Integer> elseAdrFix = new ArrayDeque<Integer>();
	List<Integer> orPartAdr = null;
	Deque<ArrayList<Integer>> breakAdr = new ArrayDeque<ArrayList<Integer>>();
	Deque<Integer> whileStartRetAdr = new ArrayDeque<Integer>();
	List<Obj> classes = new ArrayList<Obj>();
	Deque<Obj> poziviObj = new ArrayDeque<Obj>();
	CodeConstString strConstCode = new CodeConstString(); 
	
	void printStr()
    {
        printStringAdr = Code.pc;
        Code.put(Code.enter);
        Code.put(1); 
        Code.put(3);					// za duzinu niza i iterator kao lokalne prom
        
        Code.put(Code.const_n);			// i = 0;
        Code.put(Code.store_2);
        
        Code.put(Code.load_n);			// length = arraylength(string);
        Code.put(Code.arraylength);
        Code.put(Code.store_1);
        
        Code.put(Code.load_2);			// while (i < length)
        Code.put(Code.load_1);
        Code.put(Code.jcc + Code.ge);
        Code.put2(15);

        Code.put(Code.load_n);			// print(string[i]);
        Code.put(Code.load_2);
        Code.put(Code.baload);
        Code.put(Code.const_1);
        Code.put(Code.bprint);
        
        Code.put(Code.load_2);			// i++;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_2);
        
        Code.put(Code.jmp);
        Code.put2(-14);
        Code.put(Code.exit);
        Code.put(Code.return_);
    }
	
	void printStrWithLength()
    {
		printStringAdrWithLength = Code.pc;
        Code.put(Code.enter);
        Code.put(2); 					// string i razmak pri stampanju
        Code.put(4); 					// za duzinu niza i iterator kao lokalne prom
        
        Code.put(Code.const_n);			// i = 0;
        Code.put(Code.store_3);
        
        Code.put(Code.load_n); 			// length = arraylength(string);
        Code.put(Code.arraylength);
        Code.put(Code.store_2);
        	
        Code.put(Code.load_3);			// while (i < length)
        Code.put(Code.load_2);
        Code.put(Code.jcc + Code.ge);
        Code.put2(15);

        Code.put(Code.load_n);			// print(string[i]);
        Code.put(Code.load_3);
        Code.put(Code.baload);
        Code.put(Code.load_1);
        Code.put(Code.bprint);
        
        Code.put(Code.load_3);			// i++;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_3);
        
        Code.put(Code.jmp);
        Code.put2(-14);
        Code.put(Code.exit);
        Code.put(Code.return_);
    }
	
	void readStr()
    {
        readStringAdr = Code.pc;
        Code.put(Code.enter);
        Code.put(1); 
        Code.put(3);					// za duzinu niza i iterator kao lokalne prom

        Code.put(Code.const_n);			// i = 0;
        Code.put(Code.store_2);
        
        Code.put(Code.load_n);			// length = arraylength(string);
        Code.put(Code.arraylength);
        Code.put(Code.store_1);

        Code.put(Code.load_2);			// while (i < length)
        Code.put(Code.load_1);
        Code.put(Code.jcc + Code.ge);
        Code.put2(14);

        Code.put(Code.load_n);			// read(string[i]);
        Code.put(Code.load_2);
        Code.put(Code.bread);
        Code.put(Code.bastore);
        
        Code.put(Code.load_2);			// i++;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_2);

        Code.put(Code.jmp);
        Code.put2(-13);
        Code.put(Code.exit);
        Code.put(Code.return_);
    }
	
	void stringConcatenate()
    {
       	catStrAdr = Code.pc;
        Code.put(Code.enter);
        Code.put(2); 
        Code.put(7);						// int i, j , lens1, lens2 i povratni nadovezan string s3

        Code.put(Code.load_n);				// lens1 = arraylength(s1);
        Code.put(Code.arraylength);
        Code.put(Code.store);
        Code.put(4);
        
        Code.put(Code.load_1);				// lens2 = arraylength(s2);
        Code.put(Code.arraylength);
        Code.put(Code.store);
        Code.put(5);
        
        Code.put(Code.load);				// s3 = new string; (duzine lens1 + lens2)
        Code.put(4);
        Code.put(Code.load);
        Code.put(5);
        Code.put(Code.add);
        Code.put(Code.newarray);
        Code.put(0);
        Code.put(Code.store);
        Code.put(6);

        Code.put(Code.load_2);				// while (i < lens1)
        Code.put(Code.load);
        Code.put(4);
        Code.put(Code.jcc + Code.ge);
        Code.put2(17);

        Code.put(Code.load);				// s3[i] = s1[i];
        Code.put(6);
        Code.put(Code.load_2);
        Code.put(Code.load_n);
        Code.put(Code.load_2);
        Code.put(Code.baload);
        Code.put(Code.bastore);

        Code.put(Code.load_2);				// i++;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_2);

        Code.put(Code.jmp);
        Code.put2(-17);
        
        Code.put(Code.load_3);				// while (j < lens2)
        Code.put(Code.load);
        Code.put(5);
        Code.put(Code.jcc + Code.ge);
        Code.put2(21);

        Code.put(Code.load);				// s3[i] = s2[j];
        Code.put(6);
        Code.put(Code.load_2);
        Code.put(Code.load_1);
        Code.put(Code.load_3);
        Code.put(Code.baload);
        Code.put(Code.bastore);
        
        Code.put(Code.load_2);				// i++;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_2);

        Code.put(Code.load_3);				// j++;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_3);

        Code.put(Code.jmp);
        Code.put2(-21);
        Code.put(Code.load);				// stavlja se s3 na stek
        Code.put(6);
        
        Code.put(Code.exit);
        Code.put(Code.return_);
    }
	
	void stringEquals()
    {
		eqStrAdr = Code.pc;
        Code.put(Code.enter);
        Code.put(2); 						// string s1, s2;
        Code.put(6);						// int i, len1, len2; bool flag;

        Code.put(Code.load_n);				// len1 = arraylength(s1);
        Code.put(Code.arraylength);
        Code.put(Code.store_3);
        
        Code.put(Code.load_1);				// len2 = arraylength(s2);
        Code.put(Code.arraylength);
        Code.put(Code.store);
        Code.put(4);
        
        Code.put(Code.const_1);				// flag = true;
        Code.put(Code.store);
        Code.put(5);
        
        Code.put(Code.load_3);				// if (len1 != len2) 
        Code.put(Code.load);				
        Code.put(4);
        Code.put(Code.jcc + Code.eq);
        Code.put2(9);
        Code.put(Code.const_n);				// flag = false;
        Code.put(Code.store);
        Code.put(5);
        Code.put(Code.jmp);					// skace na return
        Code.put2(36);	
        
        Code.put(Code.const_n);				// i = 0;
        Code.put(Code.store_2);
        
        Code.put(Code.load_2);				// while (i < len1)
        Code.put(Code.load);
        Code.put(3);
        Code.put(Code.jcc + Code.ge);
        Code.put2(25);

        Code.put(Code.load_n);				// if (s1[i] != s2[i])
        Code.put(Code.load_2);
        Code.put(Code.baload);
        Code.put(Code.load_1);
        Code.put(Code.load_2);
        Code.put(Code.baload);
        Code.put(Code.jcc + Code.eq);
        Code.put2(9);
        Code.put(Code.const_n);				// flag = false;
        Code.put(Code.store);
        Code.put(5);
        Code.put(Code.jmp);					// skace na return
        Code.put2(13);	
        
        Code.put(Code.load_2);				// i--;
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.put(Code.store_2);

        Code.put(Code.jmp);
        Code.put2(-25);
        
        Code.put(Code.const_1);				// flag = true;
        Code.put(Code.store);
        Code.put(5);
        
        Code.put(Code.load);				// stavlja se flag na stek
        Code.put(5);
        
        Code.put(Code.exit);
        Code.put(Code.return_);
    }
	
	void createvTable()
    {
        if (parser.errorFound) 
        {
        	return;
        }
        
        Set<Obj> methods = null;
        Set<String> methodNames = null;
        boolean firstMethod = true;

        for (Obj o :classes)
        {
            Struct typeCl = o.getType();
            while (typeCl != null)
            {
                for (Obj obj : typeCl.getMembers())
                {
                    if (obj.getKind() != Obj.Meth) 
                    {
                    	continue;
                    }

                    if (firstMethod) 
                    {
                    	methods = new HashSet<Obj>();
                    	methodNames = new HashSet<String>();
                        o.setAdr(Code.dataSize);				// postavlja vTable adresu u polje Adr obj cvora klase
                        firstMethod = false;
                    } 
                        
                    if (methodNames.contains(obj.getName() + obj.getLevel()))
                	{
                    	continue;
                	}
                    
                    methods.add(obj);
                    methodNames.add(obj.getName() + obj.getLevel());
                }
                typeCl = typeCl.getElemType();
            } 

            if (!firstMethod)
            {
                for (Obj method : methods)
                {
                	methodTable.addFunctionEntry(method.getName(), method.getAdr());
                }

                methodTable.addTableTerminator();
                firstMethod = true;
            }
        } 
    }

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // Mulop ::= MOD 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.rem;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // Mulop ::= DIV 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.div;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // Mulop ::= TIMES 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.mul;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // Addop ::= MINUS 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   RESULT = Code.sub;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // Addop ::= PLUS 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   RESULT = Code.add;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Relop ::= LESS_OR_EQUAL 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.le;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Relop ::= LESS 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.lt;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Relop ::= GREATER_OR_EQUAL 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.ge;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Relop ::= GREATER 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.gt;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Relop ::= NOT_EQUAL 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.ne;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= EQUAL 
            {
              Object RESULT =null;
		int relleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int relright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object rel = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			  RESULT = Code.eq;
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // DesignatorPart ::= LBRACKET error RBRACKET 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					   parser.report_error("[Izraz za indeksiranje niza] Izvrsen oporavak do ] u liniji "+eleft,null);
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorPart",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // DesignatorPart ::= DOT IDENT 
            {
              Object RESULT =null;
		int namePartleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int namePartright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object namePart = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					   numBrack = 2;
					   Obj tempSubObj = null; 
					   if (currentDesignator.getType().getKind() == Struct.Array)
						   tempSubObj = currentDesignator.getType().getElemType().getMembersTable().searchKey(namePart.toString());
					   else 
					   if (currentDesignator.getType().getKind() == Struct.Class)
						   tempSubObj = currentDesignator.getType().getMembersTable().searchKey(namePart.toString());
					   else
						   parser.report_error("[Greska]Linija: " + namePartleft + ": ime " + namePart.toString() + " nije klasa! " , null);
						   
					   if(tempSubObj == null)
						   parser.report_error("[Greska]Linija: " + namePartleft + ": ime " + namePart.toString() + " nije deklarisano! " , null);
					   else
					   {
						   currentDesignator = tempSubObj;
						   if (tempSubObj.getKind() == Obj.Meth)
							   parser.report_info("Poziv metode unutrasnje klase: Pretraga na " + namePartleft + " (" + namePart.toString() + ")" + ", nadjeno " + parser.writeObj(tempSubObj), null);
						   else if (tempSubObj.getKind() == Obj.Fld)
							   parser.report_info("Pristup polju unutrasnje klase: Pretraga na " + namePartleft + " (" + namePart.toString() + ")" + ", nadjeno " + parser.writeObj(tempSubObj), null);
						   else
							   parser.report_error("[Greska]Linija: " + namePartleft + ": " + namePart.toString() + " nije ni polje ni metoda unutrasnje klase! " , null);
						   lastClass = namePartleft;
					   }
					   RESULT = tempSubObj;
					   arrayType = tempSubObj;
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorPart",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // DesignatorPart ::= LBRACKET NT$25 Expr RBRACKET 
            {
              Object RESULT =null;
              // propagate RESULT from NT$25
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int lbleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int lbright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object lb = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					   numBrack = 1;
					   if (((Struct)t).getKind() != Struct.Int)
					   {
						   parser.report_error("[Greska]Linija: " + tleft + ": indeks nije tipa int!" , null);
					   }
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorPart",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // NT$25 ::= 
            {
              Object RESULT =null;
		int lbleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lbright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object lb = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					  if (currentDesignator.getType().getKind() != Struct.Array)
				      {
					      parser.report_error("[Greska]Linija: " + lbleft + ": Niz ne prethodi indeksu! " , null);
				      }	
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$25",78, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // DesignatorList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // DesignatorList ::= DesignatorList DesignatorPart 
            {
              Object RESULT =null;
		int resleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int resright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object res = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int namePartleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int namePartright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object namePart = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					   if (numBrack == 2)
					   {
						   hasDes = true;
						   RESULT = namePart;
						   arrayType = (Obj)RESULT;
					   }
					   else
					   {
						   hasDes = true;
						   RESULT = new Obj(Obj.Elem, "", arrayType.getType().getElemType());
						   arrayType = (Obj)RESULT;
					   }
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Designator ::= IDENT LBRACKET error RBRACKET 
            {
              Obj RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				   parser.report_error("[Izraz za indeksiranje niza] Izvrsen oporavak do ] u liniji "+eleft,null);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Designator ::= IDENT 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   Obj obj = Tab.find(name.toString());
			   	   
			   	   if (obj == Tab.noObj)
			   	   {
			   		   parser.report_error("[Greska]Linija: " + nameleft + ": ime " + name.toString() + " nije deklarisano! " , null);
			   	   }
			   	   else
			   	   {
			   		   currentDesignator = obj;

			   		   if (obj.getType().getKind() == 6)	//string
		   			   {
			   			   parser.report_info("String: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
		   			   }
			   		   
			   		   if (obj.getKind() == Obj.Meth)
		   			   {
			   			   if (currentClass != null)
			   				   parser.report_info("Poziv metode unutrasnje klase: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   			   else
			   				   parser.report_info("Poziv globalne funkcije: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
		   			   }
			   		   else if (obj.getKind() == Obj.Fld)
		   			   {
			   			   parser.report_info("Pristup polju unutrasnje klase: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
		   			   }
			   		   else if (obj.getKind() == Obj.Var)
			   		   {
			   			   if (obj.getLevel() == 0)//globalna
			   			   {
			   				   parser.report_info("Globalna promenljiva: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   			   }
			   			   else
			   			   {
			   				   // da li je lokalna ili form param
			   				   Collection<Obj> scopeLocals = Tab.currentScope.getOuter().getLocals().symbols();
			   				   int numLocals = Tab.currentScope.getOuter().getLocals().numSymbols();
			   				   Obj methodObj = null;
			   				   int i = 0;
			   				   for (Obj o:scopeLocals)
			   				   {
			   					   if (i == numLocals - 1) {methodObj = o; break;}
			   					   i++;
			   				   }
			   				   numLocals = methodObj.getLevel();	//broj param
			   				   scopeLocals = Tab.currentScope.getLocals().symbols();	// u opsegu metode
			   				   i = 0;
			   				   for (Obj o:scopeLocals)
			   				   {
			   					   if (o.getName().equals(name.toString()))
			   					   {
			   						   if (i < numLocals)
			   							   parser.report_info("Formalni argument funkcije: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   						   else
			   							   parser.report_info("Lokalna promenljiva: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   					   break;
			   					   }
			   					   i++;
			   				   }
			   			   }
			   		   }
			   		   else if (obj.getKind() == Obj.Con)
			   		   {
			   			   parser.report_info("Konstanta: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   			   if (obj.getType().getKind() == 6)
			   			   {
			   				   strC = Tab.find("#" + name.toString());
			   			   }
			   		   }
			   			   
			   	   }
			   	   	RESULT = obj;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Designator ::= IDENT LBRACKET NT$23 Expr RBRACKET NT$24 DesignatorList 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$24
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int namePartleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int namePartright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object namePart = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   if (hasDes)
				   {
					   RESULT = (Obj)namePart;
					   hasDes = false;
				   }
			   	   arrayType = null;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // NT$24 ::= 
            {
              Obj RESULT =(Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				   if (((Struct)t).getKind() != Struct.Int)
			   	   {
			   		   parser.report_error("[Greska]Linija: " + tleft + ": indeks nije tipa int!" , null);
			   	   }
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$24",77, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // NT$23 ::= 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				   Obj obj = Tab.find(name.toString());
			   	   if (obj == Tab.noObj)
			   	   {
			   		   parser.report_error("[Greska]Linija: " + nameleft + ": ime " + name.toString() + " nije deklarisano! " , null);
			   	   }
			   	   else
			   	   {
			   		   if (obj.getType().getKind() == Struct.Array)
			   		   {
			   			   RESULT = new Obj(Obj.Elem, "", obj.getType().getElemType());
			   			   Code.load(obj);
			   			   arrayType = RESULT;
			   			   theArr = RESULT;
			   			   
			   			   if (obj.getType().getElemType().getKind() == 6)	//string
			   			   {
				   			   parser.report_info("String: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   			   }
			   			   if (obj.getKind() == Obj.Fld)
			   			   {
				   			   parser.report_info("Pristup polju unutrasnje klase: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   			   }
			   			   else if (obj.getKind() == Obj.Var)
				   		   {
				   			   if (obj.getLevel() == 0)//globalna
				   			   {
				   				   parser.report_info("Globalna promenljiva: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
				   			   }
				   			   else
				   			   {
				   				   // da li je lokalna ili form param
				   				   Collection<Obj> scopeLocals = Tab.currentScope.getOuter().getLocals().symbols();
				   				   int numLocals = Tab.currentScope.getOuter().getLocals().numSymbols();
				   				   Obj methodObj = null;
				   				   int i = 0;
				   				   for (Obj o:scopeLocals)
				   				   {
				   					   if (i == numLocals - 1) {methodObj = o; break;}
				   					   i++;
				   				   }
				   				   numLocals = methodObj.getLevel();						//broj param
				   				   scopeLocals = Tab.currentScope.getLocals().symbols();	// u opsegu metode
				   				   i = 0;
				   				   for (Obj o:scopeLocals)
				   				   {
				   					   if (o.getName().equals(name.toString()))
				   					   {
				   						   if (i < numLocals)
				   							   parser.report_info("Formalni argument funkcije: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
				   						   else
				   							   parser.report_info("Lokalna promenljiva: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
				   					   break;
				   					   }
				   					   i++;
				   				   }
				   			   }
				   		   }
			   		   }
			   		   else
			   		   {
			   			   parser.report_error("[Greska]Linija: " + nameleft + ": ime " + name.toString() + " nije tipa niz! " , null);
			   		   }
			   		   currentDesignator = obj;
			   	   }
			   	   lastClass = nameleft;
			   	   
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$23",76, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Designator ::= IDENT DOT IDENT NT$22 DesignatorList 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$22
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int namesubleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int namesubright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object namesub = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int namePartleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int namePartright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object namePart = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   if (hasDes)
				   {
					   RESULT = (Obj)namePart;
					   hasDes = false;
				   }
				   arrayType = null;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // NT$22 ::= 
            {
              Obj RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int namesubleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int namesubright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object namesub = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

				   Obj obj = Tab.find(name.toString());
				   Obj subobj = Tab.noObj;
				   if(obj == Tab.noObj)
				   {
					   parser.report_error("[Greska]Linija: " + nameleft + ": klasa " + name.toString() + " nije deklarisana! " , null);
				   }
				   else
				   {
					   if (obj.getKind() == Obj.Var)
			   		   {
			   			   if (obj.getLevel() == 0)//globalna
			   			   {
			   				   parser.report_info("Globalna promenljiva: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   			   }
			   			   else
			   			   {
			   				   // da li je lokalna ili form param
			   				   Collection<Obj> scopeLocals = Tab.currentScope.getOuter().getLocals().symbols();
			   				   int numLocals = Tab.currentScope.getOuter().getLocals().numSymbols();
			   				   Obj methodObj = null;
			   				   int i = 0;
			   				   for (Obj o:scopeLocals)
			   				   {
			   					   if (i == numLocals - 1) {methodObj = o; break;}
			   					   i++;
			   				   }
			   				   numLocals = methodObj.getLevel();						//broj param
			   				   scopeLocals = Tab.currentScope.getLocals().symbols();	// u opsegu metode
			   				   i = 0;
			   				   for (Obj o:scopeLocals)
			   				   {
			   					   if (o.getName().equals(name.toString()))
			   					   {
			   						   if (i < numLocals)
			   							   parser.report_info("Formalni argument funkcije: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   						   else
			   							   parser.report_info("Lokalna promenljiva: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   					   break;
			   					   }
			   					   i++;
			   				   }
			   			   }
			   		   }
					   else if (obj.getKind() == Obj.Fld)
					   {
						   parser.report_info("Pristup polju unutrasnje klase: Pretraga na " + nameleft + " (" + name.toString() + ")" + ", nadjeno " + parser.writeObj(obj), null);
					   }
					   
					   if(obj.getType().getKind() != Struct.Class)
					   {
						   parser.report_error("[Greska]Linija: " + nameleft + ": ocekivana klasa! " , null);
					   }
					   else
					   {
						   subobj = obj.getType().getMembersTable().searchKey(namesub.toString());
						   RESULT = subobj;
						   arrayType = subobj;
						   if(subobj == null && !name.toString().equals("this"))
							   parser.report_error("[Greska]Linija: " + namesubleft + ": ime " + namesub.toString() + " nije deklarisano! " , null);
						   else
						   {
							   // pristup polju unutrasnje klase
							   if (name.toString().equals("this"))
							   {
								   Obj prekoThis = Tab.currentScope.getOuter().findSymbol(namesub.toString());
								   if (prekoThis == null)
									   parser.report_error("[Greska]Linija: " + namesubleft + ": ime " + namesub.toString() + " nije deklarisano! " , null);
								   else
								   {
									   currentDesignator = prekoThis;
									   if (prekoThis.getKind() == Obj.Meth)
										  parser.report_info("Poziv metode unutrasnje klase: Pretraga na " + namesubleft + " (" + namesub.toString() + ")" + ", nadjeno " + parser.writeObj(prekoThis), null);
									   else if (prekoThis.getKind() == Obj.Fld)
										   parser.report_info("Pristup polju unutrasnje klase: Pretraga na " + namesubleft + " (" + namesub.toString() + ")" + ", nadjeno " + parser.writeObj(prekoThis), null);
									   else
										   parser.report_error("[Greska]Linija: " + namesubleft + ": " + namesub.toString() + " nije ni polje ni metoda unutrasnje klase! " , null);
								   }
								   RESULT = prekoThis;
								   arrayType = prekoThis;
							   }
							   else
							   {
								   currentDesignator = subobj;
								   if (subobj.getKind() == Obj.Meth)
									   parser.report_info("Poziv metode unutrasnje klase: Pretraga na " + namesubleft + " (" + namesub.toString() + ")" + ", nadjeno " + parser.writeObj(subobj), null);
								   else
									   parser.report_info("Pristup polju unutrasnje klase: Pretraga na " + namesubleft + " (" + namesub.toString() + ")" + ", nadjeno " + parser.writeObj(subobj), null);
							   }
							   lastClass = namesubleft;
						   }
					   }
				   }  
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$22",75, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // Factor ::= LPAREN Expr RPAREN 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			   RESULT = name;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Factor ::= NEW Type LBRACKET Expr RBRACKET 
            {
              Object RESULT =null;
		int someTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int someTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct someType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
			   Obj obj = currentDesignator;
		   	   boolean ok = true;
			   if (Struct.Class == someType.getKind())	// da li je klasa
			   {
				   ok = false;
				   parser.report_info("Pravljenje objekta unutrasnje klase: Pretraga na " + someTypeleft + "(" + obj.getName() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   }
			   if (((Struct)t).getKind() != Struct.Int)
			   {
				   ok = false;
				   parser.report_error("[Greska]Linija: " + tleft + " Indeks mora biti tipa int!", null);  
			   }
			   if (ok)
			   {
				   Code.put(Code.newarray);
				   if (currentType.equals(Tab.charType))
					   Code.put(0);						// velicine bajta
				   else
					   Code.put(1);						// velicine reci
			   }
			   RESULT = new Struct(Struct.Array, currentType);
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // Factor ::= NEW Type 
            {
              Object RESULT =null;
		int someTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int someTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct someType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   Obj obj = currentDesignator;
			   if (Struct.Class == someType.getKind())	// da li je klasa
			   {
				   parser.report_info("Pravljenje objekta unutrasnje klase: Pretraga na " + someTypeleft + "(" + obj.getName() + ")" + ", nadjeno " + parser.writeObj(obj), null);
			   
				   Code.put(Code.new_);
				   Code.put2(someType.getNumberOfFields() * 4); 	// * 4 jer ima 2B 
				   
				   Code.put(Code.dup);
                   Code.loadConst(currentTypeObj.getAdr());
                   
                   Code.put(Code.putfield);
                   Code.put2(0);				// init vTable
			   }
			   else
			   {
				   parser.report_error("[Greska]Linija: " + someTypeleft + " Tip za koji se kreira objekat mora da bude unutrasnja klasa!", null);  
			   }
			   RESULT = currentType;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Factor ::= STRCONST 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   RESULT = stringType;
		  	   
		  	   Code.loadConst(((String)name).length());			// alokacija na heapu
		  	   Code.put(Code.newarray);
		  	   Code.put(0);
		  	   
               for (int i = 0; i < ((String)name).length(); i++)
               {
                   Code.put(Code.dup); 							// bastore skida adresu, pa mora da se izvrsi duplikacija
                   Code.loadConst(i);							// indeks
                   Code.loadConst(((String)name).charAt(i));	// karakter
                   Code.put(Code.bastore);						// store elementa
               }
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Factor ::= Val 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj name = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   RESULT = name.getType();
		  	   Code.load(name);			// stavlja na Expression Stack
		  	   currentIndex = name;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Factor ::= Designator LPAREN NT$21 ActPars RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$21
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int numActParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int numActParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object numActPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
			   if (parser.mainMethod) parser.main_method_calls++;
			   if (func != null)
			   {
				   Collection<Obj> parameters = func.getLocalSymbols();
			   	   boolean isClassM = false;
			   	   for (Obj o:parameters)
			   	   {
			   		   if (o.getName().equals("this"))
			   		   {
			   			   isClassM = true;
			   			   break;
			   		   }
			   	   }
			   	   boolean skip = false;
			   	   if (!func.equals(Tab.noObj) && func.getKind() != Obj.Meth)
					  parser.report_error("[Greska]Linija: " + funcleft + " " + func.getName() + " nije metoda!", null);
			  	   
			   	   if (func.getName().equals("chr"))
		  		   {
			   		   if (theArr != null)
			   		   {
			   			   currentDesignator = theArr;
			   		   }
			   		   if (!currentDesignator.getType().equals(Tab.intType) || (int)numActPars > 1)
			   			   parser.report_error("[Greska]Linija: " + funcleft + " Funkcija chr pri pozivu ima 1 parametar tipa int!", null);  
			   		   else
			   			   skip = true;
		  		   }
			  	   else if (func.getName().equals("ord"))
			  	   {
			  		   if (theArr != null)
			   		   {
			   			   currentDesignator = theArr;
			   		   }
			  		   if (!currentDesignator.getType().equals(Tab.charType) || (int)numActPars > 1)
			  			   parser.report_error("[Greska]Linija: " + funcleft + " Funkcija ord pri pozivu ima 1 parametar tipa char!", null);  
			  		   else
			  			   skip = true;
			  	   }
			  	   else if (func.getName().equals("len"))
		  		   {
			  		   if (theArr != null)
			   		   {
			   			   currentDesignator = theArr;
			   		   }
			  		   if ((currentDesignator.getType().getKind() != 6 && currentDesignator.getType().getKind() != Struct.Array)  || (int)numActPars > 1)
			  			   parser.report_error("[Greska]Linija: " + funcleft + " Funkcija len pri pozivu ima 1 parametar tipa string ili array!", null);  
			  		   else
			  		   {
			  			   skip = true;
			  			   Code.put(Code.arraylength);
			  		   }
		  		   }
			  	   if (!skip)
			  	   {
			  		 if (isClassM)	//metoda
				   	   {
				   		   if (!func.equals(Tab.noObj) && func.getLevel() - 1 != (int)numActPars && func.getKind() == Obj.Meth)
				   			   parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);  
				   	   }
				   	   else
				   	   {
				   		   boolean ok = true;
			   			   if (!func.equals(Tab.noObj) && func.getLevel() != (int)numActPars && func.getKind() == Obj.Meth)
			   			   {
			   				   ok = false;
			   				   parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);   
			   			   }
			   			   if (ok)
			   			   {
			   				   int destAdr = func.getAdr() - Code.pc;
							   Code.put(Code.call);
							   Code.put2(destAdr);
			   			   }
				   	   }
			  	   }
			  	   RESULT = func.getType(); 
			   }
			   else RESULT = func;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // NT$21 ::= 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 currentCalledFunc = func; theArr=null;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$21",74, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // Factor ::= Designator LPAREN RPAREN 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
			   if (parser.mainMethod) parser.main_method_calls++;
			   if (func != null)
			   {
				   Collection<Obj> parameters = func.getLocalSymbols();
				   boolean isClassM = false;
				   for (Obj o:parameters)
				   {
					   if (o.getName().equals("this"))
					   {
						   isClassM = true;
						   break;
					   }
				   }
				   if (isClassM)	//metoda
				   {
					   if (!func.equals(Tab.noObj) && func.getLevel() - 1 != 0 && func.getKind() == Obj.Meth)
						   parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);  
				   }
				   else
				   {
					   if (!func.equals(Tab.noObj) && func.getLevel() != 0 && func.getKind() == Obj.Meth)
						   parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);   
					   else
					   {
						   if (!func.getName().equals("noObj"))
						   {
							   if (func.getType() == Tab.noType)
								   parser.report_error("[Greska]Linija: " + funcleft + " Funkcija " + func.getName() + " ne moze se koristiti u izrazima jer nema povratnu vrednost!", null);   
						   }
						   if (!func.equals(Tab.noObj))
						   {
							   int destAdr = func.getAdr() - Code.pc;
							   Code.put(Code.call);
							   Code.put2(destAdr);
						   }
					   }
				   }
				   if (!func.equals(Tab.noObj) && func.getKind() != Obj.Meth)
					   parser.report_error("[Greska]Linija: " + funcleft + " " + func.getName() + " nije metoda!", null);
				   if (func.getName().equals("chr"))
					   parser.report_error("[Greska]Linija: " + funcleft + " Mora postojati 1 parametar metode chr tipa int!", null);  
				   else if (func.getName().equals("ord"))
					   parser.report_error("[Greska]Linija: " + funcleft + " Parametri pri pozivu metode ord mora biti tipa char!", null);  
				   else if (func.getName().equals("len"))
					   parser.report_error("[Greska]Linija: " + funcleft + " Parametri pri pozivu metode len moraju biti tipa string ili array!", null); 	
				   RESULT = func.getType();
			   }
			   else
				   RESULT = func;
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // Factor ::= Designator 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj name = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			   RESULT = name.getType();
			   if (name != null)
			   {
				   if (strC != null)
				   {
					   Code.load(strC);
					   strC = null;
				   }
				   else
					   Code.load(name);
			   }
		   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // FactorList ::= Factor 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   RESULT = name;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactorList",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // FactorList ::= FactorList Mulop Factor 
            {
              Object RESULT =null;
		int t1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object t1 = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   RESULT = name;
				   if (t1 != null && name != null)
				   {
					   if (((Struct)t1).getKind() == Struct.Int && ((Struct)name).getKind() == Struct.Int)
					   {
						   Code.put((int)op);	// t1 i name su vec na steku
					   }
					   else
					   {
							parser.report_error("[Greska]Linija: " + opleft + " Tipovi oba izraza moraju biti int!", null);
					   } 
				   }
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactorList",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // Term ::= FactorList 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 RESULT = name;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // Expr ::= Term 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 RESULT = name;
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Expr ::= MINUS Term 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 RESULT = name;
			 if (name != null)
			 {
				 if (((Struct)name).getKind() != Struct.Int)
				 {
					 parser.report_error("[Greska]Linija: " + nameleft + " Tip izraza mora biti int!", null);
				 }
				 Code.put(Code.neg);
			 }
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // Expr ::= Expr Addop Term 
            {
              Object RESULT =null;
		int t1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object t1 = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 RESULT = name;
			 if (t1 != null & name != null)
			 {
				 if (!((Struct)t1).compatibleWith((Struct)name))
				 {
					 parser.report_error("[Greska]Linija: " + opleft + " Tipovi oba izraza nisu kompatibilni!", null);
				 }
				 else
				 {
					 if (((Struct)name).getKind() == Struct.Int)
						 Code.put((int)op);	// na steku su vec t1 i name
				 }
				 if (((Struct)t1).getKind() == 6 && ((Struct)name).getKind() == 6)
				 {
					 if ((int)op == Code.sub)
					 {
						 parser.report_error("[Greska]Linija: " + opleft + " Nije validna operacija nad tipovima string!", null);
					 }
					 else
					 {
						 // konkatenacija stringova
						 Code.put(Code.call);
                         Code.put2(catStrAdr - Code.pc + 1);
					 }
				 }
				 else if (!((Struct)t1).equals(Tab.noType) && !((Struct)t1).equals(Tab.noType) && (((Struct)t1).getKind() != Struct.Int || ((Struct)name).getKind() != Struct.Int))
				 {
					 parser.report_error("[Greska]Linija: " + opleft + " Tipovi oba izraza moraju biti int ili string!", null);
				 }
			 }
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // CondFact ::= Expr Relop Expr 
            {
              Object RESULT =null;
		int t1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object t1 = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int t2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int t2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t2 = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				 if (!((Struct)t1).compatibleWith((Struct)t2))
					 parser.report_error("[Greska]Linija: " + opleft + " Tipovi oba izraza nisu kompatibilni!", null);
				 else
				 {
					 // dodatak za poredjenje stringova
					 if (((Struct)t1).getKind() == 6)
					 {
						 if ((int)op == Code.eq)
						 {
							 // poredjenje stringova na jednakost
							 Code.put(Code.call);
	                         Code.put2(eqStrAdr - Code.pc + 1);
	                         Code.put(Code.const_1);
	                         Code.putFalseJump((int)op, 0);
						 }
						 else if ((int)op == Code.ne)
						 {
							// poredjenje stringova na nejednakost
							 Code.put(Code.call);
	                         Code.put2(eqStrAdr - Code.pc + 1);
	                         Code.put(Code.const_1);
	                         Code.putFalseJump((int)op, 0);
						 }
					 }
					 else 
						 Code.putFalseJump((int)op, 0);
					 falseAdrFixS.peek().add(Code.pc - 2);
				 }
				 
				 if ((((Struct)t1).getKind() == Struct.Array || ((Struct)t1).getKind() == Struct.Class 
						 || ((Struct)t2).getKind() == Struct.Array || ((Struct)t2).getKind() == Struct.Class) &&
						 (int)op != Code.ne && (int)op != Code.eq)
					 parser.report_error("[Greska]Linija: " + opleft + " Uz klase i nizove mogu da se koriste samo != i == !", null);
				 
		     
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // CondFact ::= Expr 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				 RESULT = t;
				 if (t != null && ((Struct)t).getKind() == Struct.Bool)
				 {
					 // poredi se taj bool i 1 ==> bool == 1
					 Code.loadConst(1);
					 Code.putFalseJump(Code.eq, 0); // uslovni skok- adr je 0, i not equal
					 falseAdrFixS.peek().add(Code.pc - 2);
				 }
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // CondTerm ::= CondFact 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 	 RESULT = t;
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // CondTerm ::= CondTerm AND CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // CondTermFixed ::= CondTerm 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					  RESULT = t;
				  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTermFixed",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // Condition ::= CondTermFixed 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				  RESULT = t;
				  if (t != null && ((Struct)t).getKind() != Struct.Bool)
				  {
					  parser.report_error("[Greska]Linija: " + tleft + " Uslov nije tipa bool!", null);
				  }
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // Condition ::= Condition NT$20 OR CondTermFixed 
            {
              Object RESULT =null;
              // propagate RESULT from NT$20
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // NT$20 ::= 
            {
              Object RESULT =null;

				  	Code.putJump(0);			// ako je deo OR tacan, preskace se provera ostatka
			  		orPartAdr.add(Code.pc - 2);
                    ArrayList<Integer> uslovi = falseAdrFixS.pop();	// za false jump deo, da se skace na odgovarajuci deo
                    for (Integer i: uslovi)
                	{
                    	Code.fixup(i);
                	}
                    falseAdrFixS.push(new ArrayList<Integer>()); // kako bi se ponovilo stavlja se opet	
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$20",73, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // ConditionFixed ::= error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
					   parser.report_error("[Logicki izraz] Izvrsen oporavak do ) u liniji "+eleft,null); 
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionFixed",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // ConditionFixed ::= Condition 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConditionFixed",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // ActPars ::= Expr 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				RESULT = 1;
				// poslednji parametar
				Collection<Obj> parameters = currentCalledFunc.getLocalSymbols();
				lastVisitedParam = currentCalledFunc.getLevel() - 1;
				int i = 0;
				for (Obj o:parameters)
				{
					if (lastVisitedParam == i)
					{
						if (currentCalledFunc.getName().equals("len"))
						{
							if (((Struct)t).getKind() != 6 && ((Struct)t).getKind() != 3)
								parser.report_error("[Greska]Linija: " + tleft + " Tip stvarnog argumenta nije kompatibilan pri dodeli sa formalnim parametrom " + o.getName() + "!", null);
						}
						else if (!((Struct)t).assignableTo(o.getType()))
							parser.report_error("[Greska]Linija: " + tleft + " Tip stvarnog argumenta nije kompatibilan pri dodeli sa formalnim parametrom " + o.getName() + "!", null);
					}
					i++;
				}
				lastVisitedParam--;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // ActPars ::= Expr COMMA ActPars 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int numActParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int numActParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object numActPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				RESULT = (int)numActPars + 1;
				Collection<Obj> parameters = currentCalledFunc.getLocalSymbols();
				int i = 0;
				for (Obj o:parameters)
				{
					if (lastVisitedParam == i)
					{
						if (currentCalledFunc.getName().equals("len"))
						{
							if (((Struct)t).getKind() != 6 && ((Struct)t).getKind() != 3)
								parser.report_error("[Greska]Linija: " + tleft + " Tip stvarnog argumenta nije kompatibilan pri dodeli sa formalnim parametrom " + o.getName() + "!", null);
						}
						else if (!((Struct)t).assignableTo(o.getType()))
							parser.report_error("[Greska]Linija: " + tleft + " Tip stvarnog argumenta nije kompatibilan pri dodeli sa formalnim parametrom " + o.getName() + "!", null);
					}
					i++;
				}
				lastVisitedParam--;
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // Assignment ::= error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				   parser.report_error("[Konstrukcija iskaza dodele] Izvrsen oporavak do ; u liniji "+lleft,null);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // Assignment ::= Designator EQUALS Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					  if (d != null && d.getKind() != Obj.Var && d.getKind() != Obj.Elem && d.getKind() != Obj.Fld)
					  {
						  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije promenljiva, element niza ili polje unutar objekta!", null);
					  }
					  else if (d != null && !((Struct)name).assignableTo(d.getType()))
					  {
						  parser.report_error("[Greska]Linija: " + nameleft + " Tip nije kompatibilan pri dodeli sa " + d.getName() + "!", null);
					  }
					  else
					  {
						  if (d != null)
							  Code.store(d);
					  }
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Assignment",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // StatementMatched ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		 
						  parser.statement_cnt++; 
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // StatementMatched ::= PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int exprNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int exprNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Object exprName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
						  if (parser.mainMethod) parser.main_method_calls++;
						  if (exprName != null)
						  {
							  if (((Struct)exprName).getKind() != Struct.Int && ((Struct)exprName).getKind() != Struct.Char && ((Struct)exprName).getKind() != Struct.Bool && ((Struct)exprName).getKind() != 6)
							  {
								  parser.report_error("[Greska]Linija: " + exprNameleft + " Parametar funkcije print nije tipa int, char, bool ili string!", null);
							  }
							  else
							  {
								  if (((Struct)exprName).getKind() == Struct.Int)
			                      {
		                              Code.loadConst((int)i);
		                              Code.put(Code.print);  
			                      }
			                      else if (((Struct)exprName).getKind() == Struct.Char)
			                      {
		                              Code.loadConst((int)i);
		                              Code.put(Code.bprint);
			                      }
			                      else if (((Struct)exprName).getKind() == Struct.Bool)
			                      {
		                              Code.loadConst((int)i);
		                              Code.put(Code.print);
			                      }
			                      else if (((Struct)exprName).getKind() == 6)
								  {
			                    	  Code.loadConst((int)i);
									  Code.put(Code.call);
			                          Code.put2(printStringAdrWithLength - Code.pc + 1);
								  }
							  }
						  }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // StatementMatched ::= PRINT LPAREN Expr RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int exprNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int exprNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object exprName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
						  if (parser.mainMethod) parser.main_method_calls++;
						  if (exprName != null)
						  {
							  if (((Struct)exprName).getKind() != Struct.Int && ((Struct)exprName).getKind() != Struct.Char && ((Struct)exprName).getKind() != Struct.Bool && ((Struct)exprName).getKind() != 6)
							  {
								  parser.report_error("[Greska]Linija: " + exprNameleft + "  Parametar funkcije print nije tipa int, char, bool ili string!", null);
							  }
							  else
							  {
								  if (((Struct)exprName).getKind() == Struct.Int)
								  {
									  Code.loadConst(5);	// sirina polja
									  Code.put(Code.print);
								  }
								  else if (((Struct)exprName).getKind() == Struct.Char)
								  {
									  Code.loadConst(1);
									  Code.put(Code.bprint);
								  }
								  else if (((Struct)exprName).getKind() == Struct.Bool)
								  {
									  Code.loadConst(1);
		                              Code.put(Code.print);
								  } 
								  else if (((Struct)exprName).getKind() == 6)
								  {
									  Code.put(Code.call);
			                          Code.put2(printStringAdr - Code.pc + 1);
								  }
							  }
						  }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // StatementMatched ::= READ LPAREN Designator RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
						  if (parser.mainMethod) parser.main_method_calls++; 
						  if (d != null)
						  {
							  boolean ok = true;
							  if (d.getKind() != Obj.Var && d.getKind() != Obj.Elem && d.getKind() != Obj.Fld)
							  {
								  ok = false;
								  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije promenljiva, element niza ili polje unutar objekta!", null);
							  }
							  if (!d.getType().equals(Tab.intType) && !d.getType().equals(Tab.charType) && d.getType().getKind() != Struct.Bool && d.getType().getKind() != 6)
							  {
								  ok = false;
								  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije tipa int, char, bool ili string!", null);
							  }
							  if (ok)
							  {
								  if (d.getType() == Tab.charType)
								  {
									  Code.put(Code.bread);
		                              Code.store(d);
								  }
								  else if (d.getType().getKind() == 6)	// string
								  {
								  	  Code.load(d);
		                              Code.put(Code.call);
		                              Code.put2(readStringAdr - Code.pc + 1);
								  }
								  else if (d.getType() == Tab.intType)
								  {
									  Code.put(Code.read);
		                              Code.store(d);
		                              Code.put(Code.bread);
		                              Code.put(Code.pop);
								  }
								  else if (d.getType().getKind() == 5)
								  {
									  Code.put(Code.read);
									  Code.put(Code.const_n);
									  Code.putFalseJump(Code.eq, 0);
									  int adr = Code.pc - 2;
									  
									  Code.put(Code.const_n);
									  Code.putJump(0);
									  int adr2 = Code.pc - 2;
									  Code.fixup(adr); 
									  
									  Code.put(Code.const_1);
									  Code.fixup(adr2); 
									  
		                              Code.store(d);
		                              Code.put(Code.bread);
		                              Code.put(Code.pop);
								  }
							  }
						  }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // StatementMatched ::= RETURN Expr SEMI_COMMA 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
			               returnExists=true;
				           if (isVoid)
				        	   parser.report_error("[Greska]Linija: " + dummyleft + " Metod ne sme imati return sa izrazom jer je deklarisan sa void!", null);
				           if (!((Struct)t).equals(methReturnType))
						   {
							   parser.report_error("[Greska]Linija: " + tleft + " Tip nije isti kao povratni tip funkcije!", null);
						   }
				           else
				           {
				        	   if (!isVoid)
				        	   {
				        		   Code.put(Code.exit);
			                       Code.put(Code.return_);
				        	   }
				           }
				      
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // StatementMatched ::= RETURN SEMI_COMMA 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
						  returnExists=true;
			              if (!isVoid)
			            	  parser.report_error("[Greska]Linija: " + dummyleft + " Metod mora imati return iskaz sa izrazom jer nije deklarisan sa void!", null);
			              Code.put(Code.exit);
                          Code.put(Code.return_);
			          
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // StatementMatched ::= BREAK SEMI_COMMA 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
						   if (numWhile == 0)
							   parser.report_error("[Greska]Linija: " + dleft + " BREAK nije koriscen unutar while ciklusa!", null);
						   else
						   {
							   Code.putJump(0);
							   breakAdr.peek().add(Code.pc - 2);
						   }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // StatementMatched ::= WHILE WhileStart Cond StatementMatched 
            {
              Object RESULT =null;
		 
						   numWhile--; 
						   Code.putJump(whileStartRetAdr.pop());	// skace nazad na while (cond)
						   ArrayList<Integer> uslovi = falseAdrFixS.pop();	// preskace while, nije ispunjen
						   for (Integer i: uslovi)
						   {
							   Code.fixup(i);
						   }
						   uslovi = breakAdr.pop();	// sredjivanje break-ova
						   for (Integer i: uslovi)
						   {
							   Code.fixup(i);
						   }
					   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // StatementMatched ::= IF Cond StatementMatched BeforeElse ELSE EndIf StatementMatched AfterElse 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // StatementMatched ::= Designator DEC SEMI_COMMA 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
						  if (d != null)
						  {
							  boolean ok = true;
							  if (d.getKind() != Obj.Var && d.getKind() != Obj.Elem && d.getKind() != Obj.Fld)
							  {
								  ok = false;
								  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije promenljiva, element niza ili polje unutar objekta!", null);
							  }
							  if (!d.getType().equals(Tab.intType))
							  {
								  ok = false;
								  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije tipa int!", null);
							  }
							  if (ok)
							  {
								  if (d.getKind() == Obj.Elem)
		                          {
		                        	  Code.load(currentDesignator);
		                        	  Code.load(currentIndex);
		                          }
								  Code.load(d);
		                          Code.loadConst(1);
		                          Code.put(Code.sub);
		                          Code.store(d);
							  }
						  }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // StatementMatched ::= Designator INC SEMI_COMMA 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
					  	  if (d != null)
					  	  {
					  		boolean ok = true;
					  		if (d.getKind() != Obj.Var && d.getKind() != Obj.Elem && d.getKind() != Obj.Fld)
							  {
								  ok = false;
								  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije promenljiva, element niza ili polje unutar objekta!", null);
							  }
							  if (!d.getType().equals(Tab.intType))
							  {
								  ok = false;
								  parser.report_error("[Greska]Linija: " + dleft + " " + d.getName() + " nije tipa int!", null);
							  }
							  if (ok)
							  {
								  if (d.getKind() == Obj.Elem)
		                          {
		                        	  Code.load(currentDesignator);
		                        	  Code.load(currentIndex);
		                          }
								  Code.load(d);
		                          Code.loadConst(1);
		                          Code.put(Code.add);
		                          Code.store(d);
							  } 
					  	  }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // StatementMatched ::= Designator LPAREN RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 
						  if (parser.mainMethod) parser.main_method_calls++;
					  	  Collection<Obj> parameters = func.getLocalSymbols();
					   	  boolean isClassM = false;
					   	  for (Obj o:parameters)
					   	  {
					   		  if (o.getName().equals("this"))
					   		  {
					   			  isClassM = true;
					   			  break;
					   		  }
					   	  }
					   	  if (isClassM)	//metoda
					   	  {
					   		  if (!func.equals(Tab.noObj) && func.getLevel() - 1 != 0 && func.getKind() == Obj.Meth)
					   			  parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);  
					   	  }
					   	  else
					   	  {
				   			  if (!func.equals(Tab.noObj) && func.getLevel() != 0 && func.getKind() == Obj.Meth)
					   			  parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);   
				   			  int destAdr = func.getAdr() - Code.pc;
							  Code.put(Code.call);
							  Code.put2(destAdr);
							  if (func.getType() != Tab.noType)	//nije void
							  {
								  Code.put(Code.pop);	// ostavlja prazan expression stack
							  }
					   	  }
					  	  if (!func.equals(Tab.noObj) && func.getKind() != Obj.Meth)
							  parser.report_error("[Greska]Linija: " + funcleft + " " + func.getName() + " nije metoda!", null);
					  	  if (func.getName().equals("chr"))
					  		  parser.report_error("[Greska]Linija: " + funcleft + " Mora postojati 1 parametar metode chr tipa int!", null);  
					  	  else if (func.getName().equals("ord"))
					  		  parser.report_error("[Greska]Linija: " + funcleft + " Parametri pri pozivu metode ord mora biti tipa char!", null);  
					  	  else if (func.getName().equals("len"))
					  		  parser.report_error("[Greska]Linija: " + funcleft + " Parametri pri pozivu metode len moraju biti tipa string ili array!", null); 					  	  
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // StatementMatched ::= Designator LPAREN NT$19 ActPars RPAREN SEMI_COMMA 
            {
              Object RESULT =null;
              // propagate RESULT from NT$19
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int numActParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int numActParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object numActPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
						  if (parser.mainMethod) parser.main_method_calls++;
						  Collection<Obj> parameters = func.getLocalSymbols();
						  boolean isClassM = false;
						  for (Obj o:parameters)
						  {
							  if (o.getName().equals("this"))
							  {
								  isClassM = true;
								  break;
							  }
						  }
						  if (isClassM)	//metoda
						  {
							   if (!func.equals(Tab.noObj) && func.getLevel() - 1 != (int)numActPars && func.getKind() == Obj.Meth)
								   parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);
							   else
							   {
								   
								   if (func.getType() != Tab.noType)	//nije void
								   {
									   Code.put(Code.pop);	// ostavlja prazan expression stack
								   }
							   }
						  }
						  else
						  {
							   if (!func.equals(Tab.noObj) && func.getLevel() != (int)numActPars && func.getKind() == Obj.Meth)
								   parser.report_error("[Greska]Linija: " + funcleft + " Ne poklapa se broj formalnih i broj stvarnih parametara funkcije " + func.getName() + " !", null);   
							   else
							   {
								   int destAdr = func.getAdr() - Code.pc;
								   Code.put(Code.call);
								   Code.put2(destAdr);
								   if (func.getType() != Tab.noType)	//nije void
								   {
									   Code.put(Code.pop);	// ostavlja prazan expression stack
								   }
							   }
						  }
						  if (!func.equals(Tab.noObj) && func.getKind() != Obj.Meth)
							  parser.report_error("[Greska]Linija: " + funcleft + " " + func.getName() + " nije metoda!", null);
					  	  if (func.getName().equals("chr") && (!currentDesignator.getType().equals(Tab.intType) || (int)numActPars > 1))
					  		  parser.report_error("[Greska]Linija: " + funcleft + " Funkcija chr pri pozivu ima 1 parametar tipa int!", null);  
					  	  else if (func.getName().equals("ord") && (!currentDesignator.getType().equals(Tab.charType) || (int)numActPars > 1))
					  		  parser.report_error("[Greska]Linija: " + funcleft + " Funkcija ord pri pozivu ima 1 parametar tipa char!", null);  
					  	  else if (func.getName().equals("len") && ((currentDesignator.getType().getKind() != 6 && currentDesignator.getType().getKind() != Struct.Array ) || (int)numActPars > 1))
					  		  parser.report_error("[Greska]Linija: " + funcleft + " Funkcija len pri pozivu ima 1 parametar tipa string ili array!", null);  
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // NT$19 ::= 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj func = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
 currentCalledFunc = func; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$19",72, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // StatementMatched ::= Assignment 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementMatched",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // Cond ::= LPAREN NT$18 ConditionFixed RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$18
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
			for (Integer i: orPartAdr)	// ako je 1 deo uslova u OR true
			{
				Code.fixup(i);
			}
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Cond",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // NT$18 ::= 
            {
              Object RESULT =null;

			falseAdrFixS.push(new ArrayList<Integer>());
			orPartAdr = new ArrayList<Integer>();
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$18",71, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // EndIf ::= 
            {
              Object RESULT =null;
		
		  		ArrayList<Integer> uslovi = falseAdrFixS.peek();
				if (uslovi != null)
				{
					for (Integer i: uslovi)
					{
						Code.fixup(i);
					}
					falseAdrFixS.pop();
				}
		  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("EndIf",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // AfterElse ::= 
            {
              Object RESULT =null;
		
					Integer i = elseAdrFix.pop();
			  		Code.fixup(i);
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("AfterElse",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // BeforeElse ::= 
            {
              Object RESULT =null;
		
			   		// ako je uslov bio true, preskace se else
					Code.putJump(0);
					elseAdrFix.push(Code.pc - 2);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("BeforeElse",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // WhileStart ::= 
            {
              Object RESULT =null;
		 
			   		numWhile++; 
					breakAdr.push(new ArrayList<Integer>());
					whileStartRetAdr.push(Code.pc);				// cuva se povratna adresa
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("WhileStart",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // StatementUnmatched ::= WHILE WhileStart Cond StatementUnmatched 
            {
              Object RESULT =null;
		 
						   numWhile--; 
						   Code.putJump(whileStartRetAdr.pop());	// skace nazad na while (cond)
						   ArrayList<Integer> uslovi = falseAdrFixS.pop();	// preskace while, nije ispunjen
						   for (Integer i: uslovi)
						   {
							   Code.fixup(i);
						   }
						   uslovi = breakAdr.pop();	// sredjivanje break-ova
						   for (Integer i: uslovi)
						   {
							   Code.fixup(i);
						   }
					   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementUnmatched",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // StatementUnmatched ::= IF Cond StatementMatched BeforeElse ELSE EndIf StatementUnmatched AfterElse 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementUnmatched",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // StatementUnmatched ::= IF Cond Statement EndIf 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementUnmatched",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Statement ::= StatementMatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Statement ::= StatementUnmatched 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object typeName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			 Obj typeNode = Tab.find(typeName.toString());
			 if (typeNode == Tab.noObj)
			 {
				 //ime ne postoji u tabeli simbola, treba prijaviti semanticku gresku
				 parser.report_error("[Greska]Linija: " + typeNameleft + " Nije pronadjen tip " + typeName + " u tabeli simbola!", null);
				 currentType = Tab.noType;
				 currentTypeObj = Tab.noObj;
			 }
			 else
			 {
				 if (Obj.Type == typeNode.getKind())
				 {
					 currentTypeObj = typeNode;
					 currentType = typeNode.getType();
					 RESULT = currentType;
				 }
				 else
				 {
					 // ne predstavlja tip, nego nesto drugo; greska
					 parser.report_error("[Greska]Linija: " + typeNameleft + " Ime " + typeName + " ne predstavlja tip ", null);
					 currentType = Tab.noType;
				 }
			 }
			 
		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // FormPar ::= Type IDENT LBRACKET RBRACKET 
            {
              Object RESULT =null;
		int formVarNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int formVarNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object formVarName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
				parser.formal_param_cnt++;
				if (parser.wrongReturnTypeOverride == false)
				{
					if (parser.mainMethod)
						   parser.report_error("[Greska]Linija: " + formVarNameleft + " " + formVarName.toString() + " ne sme da bude parametar main metode jer main nema parametre!", null);
					else if (Tab.currentScope.findSymbol(formVarName.toString()) != null)
				   		parser.report_error("[Greska]Linija: " + formVarNameleft + " " + formVarName + " je vec deklarisano", null);
					else 
						Tab.insert(Obj.Var, formVarName.toString(), new Struct(Struct.Array, currentType));
				}
				if (overridenMethod != null && parser.mismatched == true)
				{
					int i = 0;
					for(Obj o:overridenMethod.getLocalSymbols())
					{
						if ((i == Tab.currentScope.getnVars() - 1) && (o.getType().getKind() == Struct.Array) && (o.getType().getElemType().getKind() == currentType.getKind())) break;
						i++;
					}
					if (i == overridenMethod.getLocalSymbols().size())
						parser.mismatched = true;
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // FormPar ::= Type IDENT 
            {
              Object RESULT =null;
		int methTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int methTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct methType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int formVarNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int formVarNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object formVarName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
				parser.formal_param_cnt++;
				if (parser.wrongReturnTypeOverride == false)
				{
					if (parser.mainMethod)
						   parser.report_error("[Greska]Linija: " + formVarNameleft + " " + formVarName.toString() + " ne sme da bude parametar main metode jer main nema parametre!", null);
					else if (Tab.currentScope.findSymbol(formVarName.toString()) != null)
				   		   parser.report_error("[Greska]Linija: " + formVarNameleft + " " + formVarName + " je vec deklarisano", null);
					else 
						Tab.insert(Obj.Var, formVarName.toString(), currentType);
				}
				if (overridenMethod != null && parser.mismatched == true)
				{
					int i = 0;
					for(Obj o:overridenMethod.getLocalSymbols())
					{
						if ((i == Tab.currentScope.getnVars() - 1) && (o.getType().getKind() == currentType.getKind())) break;
						i++;
					}
					if (i == overridenMethod.getLocalSymbols().size())
						parser.mismatched = true;
				}
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPar",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // FormPars ::= FormPar 
            {
              Object RESULT =null;
		 
				 RESULT = 1; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // FormPars ::= FormPars COMMA FormPar 
            {
              Object RESULT =null;
		int numForParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int numForParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object numForPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
				 RESULT = (int)numForPars + 1; 
			 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // MethodPars ::= error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   parser.report_error("[Deklaracija form. parametra funkcije] Izvrsen oporavak do ) u liniji "+eleft,null);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // MethodPars ::= error COMMA FormPars 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   parser.report_error("[Deklaracija form. parametra funkcije] Izvrsen oporavak do , u liniji "+eleft,null);
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // MethodPars ::= 
            {
              Object RESULT =null;
		 
				   RESULT = 0; 
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // MethodPars ::= FormPars 
            {
              Object RESULT =null;
		int numForParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int numForParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object numForPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				  RESULT = numForPars; 
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodPars",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // MethodName ::= IDENT 
            {
              Obj RESULT =null;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object methName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   if (methName.equals("main")) 
				   {
					   if (!currentType.equals(Tab.noType))
						   parser.report_error("[Greska]Linija: " + methNameleft + " " + methName.toString() + " mora da bude void metoda!", null);
					   parser.mainMethod = true;  
				   }
			  	   
				   // da li je takva metoda sa tim imenom vec deklarisana i nije u pitanju nasledjena metoda
				   if (Tab.currentScope.findSymbol(methName.toString()) != null && baseClass == null)
				   {
					   parser.wrongReturnTypeOverride = true;
					   parser.report_error("[Greska]Linija: " + methNameleft + " " + methName.toString() + " je vec deklarisano", null);
				   }
				   else
				   {
					   if (baseClass == null)
					   {
						   currentMethod = Tab.insert(Obj.Meth, methName.toString(), currentType);
						   currentMethod.setAdr(Code.pc);
						   if (methName.equals("main"))
						   {
							   mainDetected = true;
							   Code.mainPc = currentMethod.getAdr();
							   Object niz[] = methodTable.toArray(); 			// vTable bajtkod
							   for (int i = 0; i < niz.length; i++) 
							   {
								   Code.buf[Code.pc++] = ((Byte)niz[i]).byteValue(); 
							   }
							   methodTable.clear();
							   
			                    for (int i = 0; i < strConstCode.size(); i++) 
			                    {
			                    	Code.buf[Code.pc++] = (strConstCode.getBuffer())[i];
			                    }
						   }
					   }
					   else
					   {
						   // mora da proveri da li postoji samo 1 pojava u current scope; tj da li vec nije doslo do override
						   Obj baseClassMethod = null;
						   for (Obj o:baseClass.getType().getMembers())
						   {
							   if (o.getName().equals(methName.toString()))
							   {
								   baseClassMethod = o;
								   break;
							   }
						   }
						   
						   if (baseClassMethod == null)	// nema tu metodu
						   {
							   currentMethod = Tab.insert(Obj.Meth, methName.toString(), currentType);
							   currentMethod.setAdr(Code.pc);
						   }
						   else
						   {
							   // da li je ista povratna vrednost
							   if (((baseClassMethod.getType().getKind() == Struct.Array) && (baseClassMethod.getType().getElemType().getKind() == currentType.getElemType().getKind())) || (baseClassMethod.getType().getKind() == currentType.getKind()))
							   {
								   int brojPojava = 0;
								   for (Obj o: Tab.currentScope.getLocals().symbols())
								   {
									   if (o.getName().equals(methName.toString()))
										   brojPojava++;
								   }
								   if (brojPojava == 1)
								   {
									   // vec je ubacena, samo treba da se azuriraju parametri
									   overridenMethod = baseClassMethod;
									   HashTableDataStructure ht = new HashTableDataStructure();
							   		   for (Obj o:baseClassMethod.getLocalSymbols())
							   		   {
							   			   ht.insertKey(o);
							   		   }
							   		   overridenMethod.setLocals(ht);
									   currentMethod = Tab.insert(Obj.Meth, "this." + methName.toString(), currentType);
									   currentMethod.setAdr(Code.pc);
								   }
								   else
								   {
									   parser.wrongReturnTypeOverride = true;
									   parser.report_error("[Greska]Linija: " + methNameleft + " " + methName.toString() + " je vec deklarisano", null);
								   }
							   }
							   else
							   {
								   parser.wrongReturnTypeOverride = true;
								   parser.report_error("[Greska]Linija: " + methNameleft + " " + methName.toString() + " se razlikuje od metode natklase po povratnom tipu!", null);
							   }
						   }
					   }
				   }
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodName",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // MethodDeclPart ::= MethodName OpenScope NT$14 LPAREN MethodPars NT$15 RPAREN LocalVarDeclList LBRACE NT$16 StatementList RBRACE NT$17 CloseScope 
            {
              Object RESULT =null;
              // propagate RESULT from NT$17
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)).right;
		Obj methName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)).value;
		int numForParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int numForParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		Object numForPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclPart",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // NT$17 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		Obj methName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		int numForParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int numForParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Object numForPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;

					   if (!parser.mainMethod && !isVoid && !returnExists) 
					   { 
			             parser.report_error("[Greska]Linija: " + methNameleft + " Metod mora imati return iskaz jer nije deklarisan sa void!", null);
			           }
                       returnExists=false;

					   if (!parser.wrongReturnTypeOverride)
					   {
						   Tab.chainLocalSymbols(currentMethod);
					   		if (overridenMethod != null)
					   		{
					   			if(parser.mismatched == true)
						   		{
						   			Tab.currentScope.getLocals().deleteKey(currentMethod.getName());
						   			parser.report_error("[Greska]Linija: " + methNameleft + " " + overridenMethod.getName() + " ne odgovara potpisu natklase!", null);
						   			Tab.currentScope.getOuter().getLocals().deleteKey(currentMethod.getName());
						   			parser.mismatched = false;
						   		}
						   		else
						   		{
						   			Obj baseNode = Tab.currentScope.getOuter().findSymbol(overridenMethod.getName());
						   			baseNode.setAdr(currentMethod.getAdr());
						   			HashTableDataStructure ht = new HashTableDataStructure();
						   			for (Obj o:currentMethod.getLocalSymbols())
						   			{
						   				ht.insertKey(o);
						   			}
						   			baseNode.setLocals(ht);
						   			Tab.currentScope.getOuter().getLocals().deleteKey(currentMethod.getName());
						   		}
					   		}  
					   }
					   if (isVoid)
					   {
						   Code.put(Code.exit);
						   Code.put(Code.return_);
					   }
					   else
					   {
						   Code.put(Code.trap);			// ako se zaobidje return -> runtime error
						   Code.put(1);
					   }
					   
			   	   	   parser.mainMethod = false;
			   		   parser.wrongReturnTypeOverride = false;
			   		   overridenMethod = null;
			   		   currentMethod = null;
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$17",70, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // NT$16 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Obj methName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int numForParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int numForParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Object numForPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;

					   Code.put(Code.enter);					// skida sa expr steka argumente metoda
				   	   Code.put(currentMethod.getLevel());
				   	   Code.put(Tab.currentScope().getnVars());	// broj promenljivih
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$16",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // NT$15 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj methName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int numForParsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int numForParsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object numForPars = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					   	// level = broj formalnih parametara
					   if (!parser.wrongReturnTypeOverride && !parser.mainMethod && numForPars != null)
					   {
						   	currentMethod.setLevel(currentMethod.getLevel() + (int)numForPars);
						    if (overridenMethod != null)
						    {
						    	if (overridenMethod.getLevel() != currentMethod.getLevel())
						    		parser.mismatched = true;	// ne moze da bude redefinisana metoda
						    }  
					   }
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$15",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // NT$14 ::= 
            {
              Object RESULT =null;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj methName = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

					   if (!parser.wrongReturnTypeOverride)
					   {
						   if (parser.inner)
						   {
							   parser.inner_class_meth_cnt++;
							   Tab.insert(Obj.Var, "this", currentClass.getType());
							   currentMethod.setLevel(1);	// jer ima this implicitni
						   }
						   else
							   parser.function_cnt++; 
					   }
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$14",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // MethodDecl ::= VOID NT$13 MethodDeclPart 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
		    	   isVoid = false; 
		       
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // NT$13 ::= 
            {
              Object RESULT =null;
 
				   isVoid = true; 
			   	   currentType = Tab.noType; 
			   	   methReturnType = Tab.noType; 
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$13",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // MethodDecl ::= Type NT$12 MethodDeclPart 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$12 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

				   isVoid = false;
				   methReturnType = currentType;
			   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$12",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // LocalMethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalMethodDeclList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // LocalMethodDeclList ::= LocalMethodDeclList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalMethodDeclList",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // ClassDeclMethodDeclaration ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclMethodDeclaration",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // ClassDeclMethodDeclaration ::= LBRACE LocalMethodDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclMethodDeclaration",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // LocalVarDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // LocalVarDeclList ::= LocalVarDeclList VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("LocalVarDeclList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // ClassBase ::= IDENT 
            {
              String RESULT =null;
		int baseNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int baseNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object baseName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				  RESULT = baseName.toString();
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassBase",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // ClassName ::= IDENT 
            {
              Obj RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object className = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				  if (Tab.currentScope.findSymbol(className.toString()) == null)
				  {
					  parser.inner_class_cnt++;
					  currentClass = Tab.insert(Obj.Type, className.toString(), new Struct(Struct.Class));
					  currentClass.setAdr(0);
					  classes.add(currentClass);
				  }
				  else
					  parser.report_error("[Greska]Linija: " + classNameleft + " " + className + " je vec deklarisano", null);
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassName",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // ClassDecl ::= CLASS ClassName EXTENDS ClassBase NT$7 OpenScope NT$8 LBRACE NT$9 LocalVarDeclList NT$10 ClassDeclMethodDeclaration RBRACE NT$11 CloseScope 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-13)).value;
		int baseClassNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int baseClassNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		String baseClassName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		
				  currentClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-14)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // NT$11 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)).value;
		int baseClassNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int baseClassNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String baseClassName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;

				  parser.inner = false;
				  parser.isGlobal = true;
				  baseClass = null;
				  
				  if (currentClass != null)
					  Tab.chainLocalSymbols(currentClass.getType());
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$11",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // NT$10 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		int baseClassNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int baseClassNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		String baseClassName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;

				  parser.local = true;
			  	  if (currentClass != null)
			  	  {
			  		// "kopira" metode natklase
					  for (Obj o: baseClass.getType().getMembers())
					  {
						  if (o.getKind() == Obj.Meth)
						  {
							  Obj attr = Tab.insert(o.getKind(), o.getName(), o.getType());
							  attr.setAdr(o.getAdr());
							  attr.setLevel(o.getLevel());
							  SymbolDataStructure locals = new HashTableDataStructure();
							  for (Obj member:o.getLocalSymbols())
							  {
								  if (member.getName().equals("this"))
									  locals.insertKey(new Obj(Obj.Var, "this", currentClass.getType()));
								  else
									  locals.insertKey(member);
							  }
							  attr.setLocals(locals);
							  attr.setFpPos(o.getFpPos());
						  }
					  }
			  	  }
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$10",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$9 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;
		int baseClassNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int baseClassNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		String baseClassName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
 
				  parser.inner = true;
				  parser.isGlobal = false; 
				  parser.local = false;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // NT$8 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int baseClassNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int baseClassNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String baseClassName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
 
				  Obj tempObj = Tab.insert(Obj.Fld, "vTableAddress", Tab.intType);  
				  tempObj.setAdr(0);
				  
				  // "kopira" polja natklase osim vTable
				  for (Obj o: baseClass.getType().getMembers())
				  {
					  if (o.getKind() == Obj.Meth) break;
					  if (!o.getName().equals("vTableAddress"))
					  {
						  Obj attr = Tab.insert(o.getKind(), o.getName(), o.getType());
						  attr.setAdr(o.getAdr());
					  }
				  }
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // NT$7 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int baseClassNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int baseClassNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String baseClassName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

				  baseClass = Tab.find(baseClassName.toString());
				  if (baseClass == Tab.noObj)
				  {
					  parser.report_error("[Greska]Linija: " + baseClassNameleft + " Klasa " + baseClassName + " nije deklarisana!", null);
				  }
				  else if (baseClass.getType().getKind() != Struct.Class)
				  {
					  parser.report_error("[Greska]Linija: " + baseClassNameleft + " Ocekivana natklasa!", null);
				  }
				  else
				  {
					  if (currentClass != null)
					  {
						  currentClass.setAdr(baseClass.getAdr());
						  currentClass.getType().setElementType(baseClass.getType());
					  }
				  }
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // ClassDecl ::= CLASS ClassName OpenScope NT$3 LBRACE NT$4 LocalVarDeclList NT$5 ClassDeclMethodDeclaration RBRACE NT$6 CloseScope 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)).value;
		
				  currentClass = null;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-11)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;

				  parser.inner = false;
				  parser.isGlobal = true;
				  
				  if (currentClass != null)
					  Tab.chainLocalSymbols(currentClass.getType());
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;

				  parser.local = true;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // NT$4 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
 
				  parser.inner = true;
				  parser.isGlobal = false; 
				  parser.local = false;
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // NT$3 ::= 
            {
              Object RESULT =null;
		int classNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int classNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj className = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				  Obj tempObj = Tab.insert(Obj.Fld, "vTableAddress", Tab.intType);
				  tempObj.setAdr(0);
			  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // VarDeclPart ::= IDENT LBRACKET RBRACKET 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object varName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
					// Brojanje lokalnih promenljivih main funkcije i globalnih nizova
					if (parser.mainMethod) parser.main_var_count++;
					else if (parser.isGlobal) parser.array_count++;
					else if (parser.inner && !parser.local) parser.inner_class_field_cnt++;
					
					Struct s = new Struct(Struct.Array);
					s.setElementType(currentType);
					// da li je ime vec deklarisano u ovom scope-u
					if (Tab.currentScope.findSymbol(varName.toString()) == null)
					{
						RESULT = Tab.insert(parser.inner && !parser.local? Obj.Fld: Obj.Var, varName.toString(), s);
						if (parser.inner && !parser.local && currentClass != null)
						{
							currentClass.setAdr(currentClass.getAdr() + 1);
							((Obj)RESULT).setAdr(currentClass.getAdr());
						}
					}
					else
						parser.report_error("[Greska]Linija: " + varNameleft + " " + varName + " je vec deklarisano", null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclPart",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // VarDeclPart ::= IDENT 
            {
              Object RESULT =null;
		int varNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int varNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object varName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					// Brojanje lokalnih promenljivih main funkcije i globalnih promenljivih
					if (parser.mainMethod) parser.main_var_count++;
					else if (parser.isGlobal) parser.var_count++;
					else if (parser.inner && !parser.local) parser.inner_class_field_cnt++;
					
					// da li je ime vec deklarisano u ovom scope-u
					if (Tab.currentScope.findSymbol(varName.toString()) == null)
					{
						RESULT = Tab.insert(parser.inner && !parser.local? Obj.Fld: Obj.Var, varName.toString(), currentType);
						if (parser.inner && !parser.local && currentClass != null)
						{
							currentClass.setAdr(currentClass.getAdr() + 1);
							((Obj)RESULT).setAdr(currentClass.getAdr());
						}
					}
					else
						parser.report_error("[Greska]Linija: " + varNameleft + " " + varName + " je vec deklarisano", null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclPart",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VarDeclList ::= VarDeclPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VarDeclList ::= error COMMA VarDeclPart 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
					if (parser.isGlobal)
						parser.report_error("[Definicija globalne promenljive] Izvrsen oporavak do , u liniji "+lleft,null); 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // VarDeclList ::= VarDeclList COMMA VarDeclPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclList",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // VarDecl ::= Type error 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				if (parser.inner && !parser.local)
					parser.report_error("[Deklaracija polja unutrasnje klase] Izvrsen oporavak do { u liniji "+eleft,null);
				else
					parser.report_error("[Deklaracija lokalne promenljive] Izvrsen oporavak do { u liniji "+eleft,null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // VarDecl ::= Type error SEMI_COMMA 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 
				if (parser.isGlobal)
					parser.report_error("[Definicija globalne promenljive] Izvrsen oporavak do ; u liniji "+lleft,null);
				else if (parser.inner && !parser.local)
					parser.report_error("[Deklaracija polja unutrasnje klase] Izvrsen oporavak do ; u liniji "+lleft,null);
				else
					parser.report_error("[Deklaracija lokalne promenljive] Izvrsen oporavak do ; u liniji "+lleft,null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // VarDecl ::= Type VarDeclList SEMI_COMMA 
            {
              Object RESULT =null;
		int currentTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int currentTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct currentType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // Val ::= CHARCONST 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = new Obj(Obj.Con, "", Tab.charType);  
			((Obj) RESULT).setAdr((char)val);
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Val",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // Val ::= BOOLCONST 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = new Obj(Obj.Con, "", boolType);
			((Obj) RESULT).setAdr((boolean)val? 1:0);
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Val",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // Val ::= NUMBER 
            {
              Obj RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			RESULT = new Obj(Obj.Con, "", Tab.intType);  
			((Obj) RESULT).setAdr((int)val); 
		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Val",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // ConstDeclIdent ::= IDENT EQUALS STRCONST 
            {
              Object RESULT =null;
		int constNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int constNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object constName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int constValueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int constValueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object constValue = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
					   if (parser.isGlobal) parser.const_count++;
					   if (Tab.currentScope.findSymbol(constName.toString()) != null)
				   		   parser.report_error("[Greska]Linija: " + constNameleft + " " + constName + " je vec deklarisano", null);
				   	   else
				   	   {
				   		   if (currentType.getKind() != 6)
				   			   parser.report_error("[Greska]Linija: " + constValueleft + " Semanticka greska u tipu!", null);
				   		   else
				   		   {
				   			   Obj stringVal = Tab.insert(Obj.Var,  "#" + constName.toString(), stringType);
				   			   stringVal.setLevel(0);
				   			   
				               strConstCode.loadConst(((String)constValue).length());
				               strConstCode.put(Code.newarray);
				               strConstCode.put(0);

				               for (int i = 0; i < ((String)constValue).length(); i++)
				               {
				                   strConstCode.put(Code.dup); 
				                   strConstCode.loadConst(i);
				                   strConstCode.loadConst(((String)constValue).charAt(i));
				                   strConstCode.put(Code.bastore);
				               }
				               
				               strConstCode.put(Code.putstatic);
					           strConstCode.put2(stringVal.getAdr());
					           
				               Obj cons = Tab.insert(Obj.Con, constName.toString(), stringType);
				               cons.setAdr(stringVal.getAdr());
				   		   }
				   	   }
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclIdent",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ConstDeclIdent ::= IDENT EQUALS Val 
            {
              Object RESULT =null;
		int constNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int constNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object constName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int constValueleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int constValueright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj constValue = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
					   if (parser.isGlobal) parser.const_count++;
				   	   if (Tab.currentScope.findSymbol(constName.toString()) != null)
				   		   parser.report_error("[Greska]Linija: " + constNameleft + " " + constName + " je vec deklarisano", null);
				   	   else
				   	   {
				   		   Obj cons = Tab.insert(Obj.Con, constName.toString(), currentType);
				   		   cons.setAdr(((Obj) constValue).getAdr());						// adr = value
				   		   if(((Obj) constValue).getType() != currentType)
				   		   {
				   			   parser.report_error("[Greska]Linija: " + constValueleft + " Semanticka greska u tipu!", null);
				   		   }
				   	   }	   
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclIdent",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ConstDeclIdentList ::= ConstDeclIdent 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclIdentList",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstDeclIdentList ::= ConstDeclIdentList COMMA ConstDeclIdent 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDeclIdentList",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ConstDecl ::= CONST Type ConstDeclIdentList SEMI_COMMA 
            {
              Object RESULT =null;
		int currentTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int currentTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct currentType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // MethodDeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclarationList",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // MethodDeclarationList ::= MethodDeclarationList MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclarationList",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // DeclarationPart ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // DeclarationPart ::= VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // DeclarationPart ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationPart",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // DeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // DeclarationList ::= DeclarationList DeclarationPart 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ProgramName ::= IDENT 
            {
              Obj RESULT =null;
		int pNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int pNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object pName = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					RESULT = Tab.insert(Obj.Prog, pName.toString(), Tab.noType);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgramName",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Program ::= PROGRAM ProgramName OpenScope NT$0 DeclarationList LBRACE NT$1 MethodDeclarationList RBRACE NT$2 CloseScope 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		
				if (!mainDetected)
					parser.report_error("[Greska]Program nema main metodu!", null);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;

				Tab.chainLocalSymbols(p);
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // NT$1 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;

				parser.isGlobal = false;
				Code.dataSize = Tab.currentScope.getnVars();
				createvTable();
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$0 ::= 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				printStr();
				printStrWithLength();
				readStr();
				stringConcatenate();
				stringEquals();
			
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // CloseScope ::= 
            {
              Object RESULT =null;
		 Tab.closeScope(); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CloseScope",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // OpenScope ::= 
            {
              Object RESULT =null;
		 Tab.openScope(); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("OpenScope",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

